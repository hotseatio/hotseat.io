# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pdf-reader` gem.
# Please instead update this file by running `bin/tapioca gem pdf-reader`.

# typed: strong
module PDF; end

# The Reader class serves as an entry point for parsing a PDF file.
#
# PDF is a page based file format. There is some data associated with the
# document (metadata, bookmarks, etc) but all visible content is stored
# under a Page object.
#
# In most use cases for extracting and examining the contents of a PDF it
# makes sense to traverse the information using page based iteration.
#
# In addition to the documentation here, check out the
# PDF::Reader::Page class.
#
# == File Metadata
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   puts reader.pdf_version
#   puts reader.info
#   puts reader.metadata
#   puts reader.page_count
#
# == Iterating over page content
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   reader.pages.each do |page|
#     puts page.fonts
#     puts page.images
#     puts page.text
#   end
#
# == Extracting all text
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   reader.pages.map(&:text)
#
# == Extracting content from a single page
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   page = reader.page(1)
#   puts page.fonts
#   puts page.images
#   puts page.text
#
# == Low level callbacks (ala current version of PDF::Reader)
#
#   reader = PDF::Reader.new("somefile.pdf")
#
#   page = reader.page(1)
#   page.walk(receiver)
#
# == Encrypted Files
#
# Depending on the algorithm it may be possible to parse an encrypted file.
# For standard PDF encryption you'll need the :password option
#
#   reader = PDF::Reader.new("somefile.pdf", :password => "apples")
class PDF::Reader
  # creates a new document reader for the provided PDF.
  #
  # input can be an IO-ish object (StringIO, File, etc) containing a PDF
  # or a filename
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #
  #   File.open("somefile.pdf","rb") do |file|
  #     reader = PDF::Reader.new(file)
  #   end
  #
  # If the source file is encrypted you can provide a password for decrypting
  #
  #   reader = PDF::Reader.new("somefile.pdf", :password => "apples")
  #
  # Using this method directly is supported, but it's more common to use
  # `PDF::Reader.open`
  #
  # @return [Reader] a new instance of Reader
  def initialize(input, opts = T.unsafe(nil)); end

  # Return a Hash with some basic information about the PDF file
  sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def info; end

  # Return a Hash with extra metadata provided by the author of the PDF file. Not
  # always present.
  sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def metadata; end

  # lowlevel hash-like access to all objects in the underlying PDF
  def objects; end

  # returns a single PDF::Reader::Page for the specified page.
  # Use this instead of pages method when you need to access just a single
  # page
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #   page   = reader.page(10)
  #
  #   puts page.text
  #
  # See the docs for PDF::Reader::Page to read more about the
  # methods available on each page
  def page(num); end

  # To number of pages in this PDF
  sig { returns(Integer) }
  def page_count; end

  # returns an array of PDF::Reader::Page objects, one for each
  # page in the source PDF.
  #
  #   reader = PDF::Reader.new("somefile.pdf")
  #
  #   reader.pages.each do |page|
  #     puts page.fonts
  #     puts page.images
  #     puts page.text
  #   end
  #
  # See the docs for PDF::Reader::Page to read more about the
  # methods available on each page
  sig { returns(T::Array[PDF::Reader::Page]) }
  def pages; end

  # The PDF version this file uses
  sig { returns(Float) }
  def pdf_version; end

  private

  # recursively convert strings from outside a content stream into UTF-8
  def doc_strings_to_utf8(obj); end

  # @return [Boolean]
  def has_utf16_bom?(str); end

  # TODO find a PDF I can use to spec this behaviour
  def pdfdoc_to_utf8(obj); end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def root; end

  # one day we'll all run on a 1.9 compatible VM and I can just do this with
  # String#encode
  def utf16_to_utf8(obj); end

  class << self
    # syntactic sugar for opening a PDF file and the most common approach. Accepts the
    # same arguments as new().
    #
    #   PDF::Reader.open("somefile.pdf") do |reader|
    #     puts reader.pdf_version
    #   end
    #
    # or
    #
    #   PDF::Reader.open("somefile.pdf", :password => "apples") do |reader|
    #     puts reader.pdf_version
    #   end
    #
    # @yield [PDF::Reader.new(input, opts)]
    def open(input, opts = T.unsafe(nil), &block); end
  end
end

# Decrypts data using the AESV2 algorithim defined in the PDF spec. Requires
# a decryption key, which is usually generated by PDF::Reader::StandardKeyBuilder
class PDF::Reader::AesV2SecurityHandler
  # @return [AesV2SecurityHandler] a new instance of AesV2SecurityHandler
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the AES-128-CBC algorithm
  #
  # version == 4 and CFM == AESV2
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  def decrypt(buf, ref); end
end

# Decrypts data using the AESV3 algorithim defined in the PDF 1.7, Extension Level 3 spec.
# Requires a decryption key, which is usually generated by PDF::Reader::KeyBuilderV5
class PDF::Reader::AesV3SecurityHandler
  # @return [AesV3SecurityHandler] a new instance of AesV3SecurityHandler
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the RC4 or AES algorithms
  #
  # used to decrypt RC4/AES encrypted PDF streams (buf)
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  def decrypt(buf, ref); end
end

# Filter our text/characters that are positioned outside a rectangle. Usually the page
# MediaBox or CropBox, but could be a user specified rectangle too
class PDF::Reader::BoundingRectangleRunsFilter
  class << self
    def runs_within_rect(runs, rect); end
  end
end

# A string tokeniser that recognises PDF grammar. When passed an IO stream or a
# string, repeated calls to token() will return the next token from the source.
#
# This is very low level, and getting the raw tokens is not very useful in itself.
#
# This will usually be used in conjunction with PDF:Reader::Parser, which converts
# the raw tokens into objects we can work with (strings, ints, arrays, etc)
class PDF::Reader::Buffer
  # Creates a new buffer.
  #
  # Params:
  #
  #   io - an IO stream (usually a StringIO) with the raw data to tokenise
  #
  # options:
  #
  #   :seek - a byte offset to seek to before starting to tokenise
  #   :content_stream - set to true if buffer will be tokenising a
  #                     content stream. Defaults to false
  #
  # @return [Buffer] a new instance of Buffer
  def initialize(io, opts = T.unsafe(nil)); end

  # return true if there are no more tokens left
  #
  # @return [Boolean]
  sig { returns(T::Boolean) }
  def empty?; end

  # return the byte offset where the first XRef table in th source can be found.
  #
  # @raise [MalformedPDFError]
  sig { returns(Integer) }
  def find_first_xref_offset; end

  # Returns the value of attribute pos.
  def pos; end

  # return raw bytes from the underlying IO stream.
  #
  #   bytes - the number of bytes to read
  #
  # options:
  #
  #   :skip_eol - if true, the IO stream is advanced past a CRLF, CR or LF
  #               that is sitting under the io cursor.
  #   Note:
  #   Skipping a bare CR is not spec-compliant.
  #   This is because the data may start with LF.
  #   However we check for CRLF first, so the ambiguity is avoided.
  def read(bytes, opts = T.unsafe(nil)); end

  # return the next token from the source. Returns a string if a token
  # is found, nil if there are no tokens left.
  sig { returns(T.any(NilClass, String, PDF::Reader::Reference)) }
  def token; end

  private

  sig { void }
  def check_size_is_non_zero; end

  # Returns true if this buffer is parsing a content stream
  #
  # @return [Boolean]
  sig { returns(T::Boolean) }
  def in_content_stream?; end

  # detect a series of 3 tokens that make up an indirect object. If we find
  # them, replace the tokens with a PDF::Reader::Reference instance.
  #
  # Merging them into a single string was another option, but that would mean
  # code further up the stack would need to check every token  to see if it looks
  # like an indirect object. For optimisation reasons, I'd rather avoid
  # that extra check.
  #
  # It's incredibly likely that the next 3 tokens in the buffer are NOT an
  # indirect reference, so test for that case first and avoid the relatively
  # expensive regexp checks if possible.
  sig { void }
  def merge_indirect_reference; end

  # peek at the next character in the io stream, leaving the stream position
  # untouched
  sig { returns(T.nilable(Integer)) }
  def peek_byte; end

  # if we're currently inside a hex string, read hex nibbles until
  # we find a closing >
  sig { void }
  def prepare_hex_token; end

  # Extract data between ID and EI
  # If the EI follows white-space the space is dropped from the data
  # The EI must followed by white-space or end of buffer
  # This is to reduce the chance of accidentally matching an embedded EI
  sig { void }
  def prepare_inline_token; end

  # if we're currently inside a literal string we more or less just read bytes until
  # we find the closing ) delimiter. Lots of bytes that would otherwise indicate the
  # start of a new token in regular mode are left untouched when inside a literal
  # string.
  #
  # The entire literal string will be returned as a single token. It will need further
  # processing to fix things like escaped new lines, but that's someone else's
  # problem.
  sig { void }
  def prepare_literal_token; end

  # Extract the next regular token and stock it in our buffer, ready to be returned.
  #
  # What each byte means is complex, check out section "3.1.1 Character Set" of the 1.7 spec
  # to read up on it.
  sig { void }
  def prepare_regular_token; end

  # attempt to prime the buffer with the next few tokens.
  sig { void }
  def prepare_tokens; end

  # Some bastard moved our IO stream cursor. Restore it.
  sig { void }
  def reset_pos; end

  # save the current position of the source IO stream. If someone else (like another buffer)
  # moves the cursor, we can then restore it.
  sig { void }
  def save_pos; end

  # tokenising behaves slightly differently based on the current context.
  # Determine the current context/state by examining the last token we found
  sig { returns(Symbol) }
  def state; end
end

PDF::Reader::Buffer::CR = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::CRLF = T.let(T.unsafe(nil), String)

# must match whole tokens
PDF::Reader::Buffer::DIGITS_ONLY = T.let(T.unsafe(nil), Regexp)

PDF::Reader::Buffer::FWD_SLASH = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::ID = T.let(T.unsafe(nil), String)

# some strings for comparissons. Declaring them here avoids creating new
# strings that need GC over and over
PDF::Reader::Buffer::LEFT_PAREN = T.let(T.unsafe(nil), String)

PDF::Reader::Buffer::LESS_THAN = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::LF = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::NULL_BYTE = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::STREAM = T.let(T.unsafe(nil), String)
PDF::Reader::Buffer::TOKEN_DELIMITER = T.let(T.unsafe(nil), Array)
PDF::Reader::Buffer::TOKEN_WHITESPACE = T.let(T.unsafe(nil), Array)

# Quite a few PDFs have trailing junk.
# This can be several k of nuls in some cases
# Allow for this here
PDF::Reader::Buffer::TRAILING_BYTECOUNT = T.let(T.unsafe(nil), Integer)

PDF::Reader::Buffer::WHITE_SPACE = T.let(T.unsafe(nil), Array)

# wraps a string containing a PDF CMap and provides convenience methods for
# extracting various useful information.
class PDF::Reader::CMap
  # @return [CMap] a new instance of CMap
  def initialize(data); end

  # Convert a glyph code into one or more Codepoints.
  #
  # Returns an array of Integers.
  def decode(c); end

  # Returns the value of attribute map.
  def map; end

  sig { returns(Integer) }
  def size; end

  private

  def bfrange_type_one(start_code, end_code, dst); end
  def bfrange_type_two(start_code, end_code, dst); end
  def build_parser(instructions); end
  def process_bfchar_instructions(instructions); end
  def process_bfrange_instructions(instructions); end
  def process_data(data, initial_mode = T.unsafe(nil)); end

  # The following includes some manual decoding of UTF-16BE strings into unicode codepoints. In
  # theory we could replace all the UTF-16 code with something based on Ruby's encoding support:
  #
  #    str.dup.force_encoding("utf-16be").encode!("utf-8").unpack("U*")
  #
  # However, some cmaps contain broken surrogate pairs and the ruby encoding support raises an
  # exception when we try converting broken UTF-16 to UTF-8
  def str_to_int(str); end
end

PDF::Reader::CMap::CMAP_KEYWORDS = T.let(T.unsafe(nil), Hash)

# A Hash-like object that wraps the array of glyph widths in a CID font
# and gives us a nice way to query it for specific widths.
#
# there are two ways to calculate a cidfont_glyph_width, that are defined
# in Section 9.7.4.3 PDF 32000-1:2008 pp 271, the differences are remarked
# on below. because of these difference that may be contained within the
# same array, it is a bit difficult to parse this array.
class PDF::Reader::CidWidths
  extend ::Forwardable

  # @return [CidWidths] a new instance of CidWidths
  def initialize(default, array); end

  def [](*args, &block); end
  def fetch(*args, &block); end

  private

  def parse_array(default, array); end

  # this is the form 10 [234 63 234 346 47 234] where width of index 10 is
  # 234, index 11 is 63, etc
  def parse_first_form(first, widths); end

  # this is the form 10 20 123 where all index between 10 and 20 have width 123
  #
  # @raise [MalformedPDFError]
  def parse_second_form(first, final, width); end
end

# Util class for working with string encodings in PDF files. Mostly used to
# convert strings of various PDF-dialect encodings into UTF-8.
class PDF::Reader::Encoding
  # @return [Encoding] a new instance of Encoding
  def initialize(enc); end

  sig { returns(T.untyped) }
  def differences; end

  # set the differences table for this encoding. should be an array in the following format:
  #
  #   [25, :A, 26, :B]
  #
  # The array alternates between a decimal byte number and a glyph name to map to that byte
  #
  # To save space the following array is also valid and equivalent to the previous one
  #
  #   [25, :A, :B]
  def differences=(diff); end

  # convert an integer glyph code into an Adobe glyph name.
  #
  #     int_to_name(65)
  #     => [:A]
  def int_to_name(glyph_code); end

  def int_to_utf8_string(glyph_code); end

  # convert the specified string to utf8
  #
  # * unpack raw bytes into codepoints
  # * replace any that have entries in the differences table with a glyph name
  # * convert codepoints from source encoding to Unicode codepoints
  # * convert any glyph names to Unicode codepoints
  # * replace characters that didn't convert to Unicode nicely with something
  #   valid
  # * pack the final array of Unicode codepoints into a utf-8 string
  # * mark the string as utf-8 if we're running on a M17N aware VM
  def to_utf8(str); end

  # Returns the value of attribute unpack.
  def unpack; end

  private

  def convert_to_utf8(str); end

  # returns a hash that:
  # - maps control chars and nil to the unicode "unknown character"
  # - leaves all other bytes <= 255 unchaged
  #
  # Each specific encoding will change this default as required for their glyphs
  sig { returns(T.untyped) }
  def default_mapping; end

  def get_mapping_file(enc); end
  def get_unpack(enc); end

  sig { returns(T.untyped) }
  def glyphlist; end

  def internal_int_to_utf8_string(glyph_code); end
  def little_boxes(times); end
  def load_mapping(file); end

  # @return [Boolean]
  sig { returns(T.untyped) }
  def utf8_conversion_impossible?; end
end

PDF::Reader::Encoding::CONTROL_CHARS = T.let(T.unsafe(nil), Array)

# ▯
PDF::Reader::Encoding::UNKNOWN_CHAR = T.let(T.unsafe(nil), Integer)

# an exception that is raised when a PDF is encrypted and we don't have the
# necessary data to decrypt it
class PDF::Reader::EncryptedPDFError < ::PDF::Reader::UnsupportedFeatureError; end

# An internal PDF::Reader class that helps to verify various parts of the PDF file
# are valid
class PDF::Reader::Error
  class << self
    # @raise [MalformedPDFError]
    def assert_equal(lvalue, rvalue); end

    # @raise [MalformedPDFError]
    def str_assert(lvalue, rvalue, chars = T.unsafe(nil)); end

    # @raise [MalformedPDFError]
    def str_assert_not(lvalue, rvalue, chars = T.unsafe(nil)); end

    # @raise [ArgumentError]
    def validate_not_nil(object, name); end

    # @raise [ArgumentError]
    def validate_type(object, name, klass); end

    # @raise [MalformedPDFError]
    def validate_type_as_malformed(object, name, klass); end
  end
end

# Utility class used to avoid modifying the underlying TextRun objects while we're
# looking for duplicates
class PDF::Reader::EventPoint
  # @return [EventPoint] a new instance of EventPoint
  def initialize(x, run); end

  # Returns the value of attribute run.
  def run; end

  # @return [Boolean]
  sig { returns(T::Boolean) }
  def start?; end

  # Returns the value of attribute x.
  def x; end
end

# Various parts of a PDF file can be passed through a filter before being stored to provide
# support for features like compression and encryption. This class is for decoding that
# content.
module PDF::Reader::Filter
  class << self
    # creates a new filter for decoding content.
    #
    # Filters that are only used to encode image data are accepted, but the data is
    # returned untouched. At this stage PDF::Reader has no need to decode images.
    def with(name, options = T.unsafe(nil)); end
  end
end

# implementation of the Ascii85 filter
class PDF::Reader::Filter::Ascii85
  # @return [Ascii85] a new instance of Ascii85
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data using the Ascii85 algorithm. Relies on the AScii85
  # rubygem.
  def filter(data); end
end

# implementation of the AsciiHex stream filter
class PDF::Reader::Filter::AsciiHex
  # @return [AsciiHex] a new instance of AsciiHex
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data using the AsciiHex algorithm.
  def filter(data); end
end

# some filter implementations support preprocessing of the  data to
# improve compression
class PDF::Reader::Filter::Depredict
  # @return [Depredict] a new instance of Depredict
  def initialize(options = T.unsafe(nil)); end

  # Streams can be preprocessed to improve compression. This reverses the
  # preprocessing
  def filter(data); end

  private

  def png_depredict(data); end
  def tiff_depredict(data); end
end

# implementation of the Flate (zlib) stream filter
class PDF::Reader::Filter::Flate
  # @return [Flate] a new instance of Flate
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the Zlib compression algorithm
  def filter(data); end

  private

  def zlib_inflate(data); end
end

# Zlib::MAX_WBITS + 32
PDF::Reader::Filter::Flate::ZLIB_AUTO_DETECT_ZLIB_OR_GZIP = T.let(T.unsafe(nil), Integer)

# Zlib::MAX_WBITS * -1
PDF::Reader::Filter::Flate::ZLIB_RAW_DEFLATE = T.let(T.unsafe(nil), Integer)

# implementation of the LZW stream filter
class PDF::Reader::Filter::Lzw
  # @return [Lzw] a new instance of Lzw
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the LZW compression algorithm
  def filter(data); end
end

# implementation of the null stream filter
class PDF::Reader::Filter::Null
  # @return [Null] a new instance of Null
  def initialize(options = T.unsafe(nil)); end

  def filter(data); end
end

# implementation of the run length stream filter
class PDF::Reader::Filter::RunLength
  # @return [RunLength] a new instance of RunLength
  def initialize(options = T.unsafe(nil)); end

  # Decode the specified data with the RunLengthDecode compression algorithm
  def filter(data); end
end

# Represents a single font PDF object and provides some useful methods
# for extracting info. Mainly used for converting text to UTF-8.
class PDF::Reader::Font
  # @return [Font] a new instance of Font
  def initialize(ohash, obj); end

  # Returns the value of attribute basefont.
  def basefont; end

  # Returns the value of attribute cid_default_width.
  def cid_default_width; end

  # Returns the value of attribute cid_widths.
  def cid_widths; end

  # Returns the value of attribute descendantfonts.
  def descendantfonts; end

  # Sets the attribute descendantfonts
  #
  # @param value the value to set the attribute descendantfonts to.
  def descendantfonts=(_arg0); end

  # Returns the value of attribute encoding.
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value the value to set the attribute encoding to.
  def encoding=(_arg0); end

  # Returns the value of attribute first_char.
  def first_char; end

  # Returns the value of attribute font_descriptor.
  def font_descriptor; end

  # looks up the specified codepoint and returns a value that is in (pdf)
  # glyph space, which is 1000 glyph units = 1 text space unit
  def glyph_width(code_point); end

  # In most cases glyph width is converted into text space with a simple divide by 1000.
  #
  # However, Type3 fonts provide their own FontMatrix that's used for the transformation.
  def glyph_width_in_text_space(code_point); end

  # Returns the value of attribute last_char.
  def last_char; end

  # Returns the value of attribute subtype.
  def subtype; end

  # Sets the attribute subtype
  #
  # @param value the value to set the attribute subtype to.
  def subtype=(_arg0); end

  def to_utf8(params); end

  # Returns the value of attribute tounicode.
  def tounicode; end

  # Sets the attribute tounicode
  #
  # @param value the value to set the attribute tounicode to.
  def tounicode=(_arg0); end

  def unpack(data); end

  # Returns the value of attribute widths.
  def widths; end

  private

  def build_encoding(obj); end

  sig do
    returns(T.any(PDF::Reader::WidthCalculator::BuiltIn, PDF::Reader::WidthCalculator::Composite, PDF::Reader::WidthCalculator::TrueType, PDF::Reader::WidthCalculator::TypeOneOrThree, PDF::Reader::WidthCalculator::TypeZero))
  end
  def build_width_calculator; end

  def default_encoding(font_name); end
  def extract_base_info(obj); end
  def extract_descendants(obj); end
  def extract_descriptor(obj); end
  def extract_type3_info(obj); end

  # Only valid for Type3 fonts
  def font_matrix_transform(x, y); end

  def to_utf8_via_cmap(params); end
  def to_utf8_via_encoding(params); end
end

# Font descriptors are outlined in Section 9.8, PDF 32000-1:2008, pp 281-288
class PDF::Reader::FontDescriptor
  # @return [FontDescriptor] a new instance of FontDescriptor
  def initialize(ohash, fd_hash); end

  # Returns the value of attribute ascent.
  def ascent; end

  # Returns the value of attribute avg_width.
  def avg_width; end

  # Returns the value of attribute cap_height.
  def cap_height; end

  # Returns the value of attribute descent.
  def descent; end

  # Returns the value of attribute font_bounding_box.
  def font_bounding_box; end

  # Returns the value of attribute font_family.
  def font_family; end

  # Returns the value of attribute font_flags.
  def font_flags; end

  # Returns the value of attribute font_name.
  def font_name; end

  # Returns the value of attribute font_stretch.
  def font_stretch; end

  # Returns the value of attribute font_weight.
  def font_weight; end

  # PDF states that a glyph is 1000 units wide, true type doesn't enforce
  # any behavior, but uses units/em to define how wide the 'M' is (the widest letter)
  sig { returns(Numeric) }
  def glyph_to_pdf_scale_factor; end

  def glyph_width(char_code); end

  # Returns the value of attribute italic_angle.
  def italic_angle; end

  # Returns the value of attribute leading.
  def leading; end

  # Returns the value of attribute max_width.
  def max_width; end

  # Returns the value of attribute missing_width.
  def missing_width; end

  # Returns the value of attribute stem_v.
  def stem_v; end

  # Returns the value of attribute x_height.
  def x_height; end

  private

  sig { returns(TTFunk::File) }
  def ttf_program_stream; end
end

# High level representation of a single PDF form xobject. Form xobjects
# are contained pieces of content that can be inserted onto multiple
# pages. They're generally used as a space efficient way to store
# repetative content (like logos, header, footers, etc).
#
# This behaves and looks much like a limited PDF::Reader::Page class.
class PDF::Reader::FormXObject
  extend ::Forwardable

  # @return [FormXObject] a new instance of FormXObject
  def initialize(page, xobject, options = T.unsafe(nil)); end

  def color_spaces(*args, &block); end

  # return a hash of fonts used on this form.
  #
  # The keys are the font labels used within the form content stream.
  #
  # The values are a PDF::Reader::Font instances that provide access
  # to most available metrics for each font.
  sig { returns(T.untyped) }
  def font_objects; end

  def fonts(*args, &block); end
  def graphic_states(*args, &block); end
  def patterns(*args, &block); end
  def procedure_sets(*args, &block); end
  def properties(*args, &block); end

  # returns the raw content stream for this page. This is plumbing, nothing to
  # see here unless you're a PDF nerd like me.
  sig { returns(T.untyped) }
  def raw_content; end

  def shadings(*args, &block); end

  # processes the raw content stream for this form in sequential order and
  # passes callbacks to the receiver objects.
  #
  # See the comments on PDF::Reader::Page#walk for more detail.
  sig { params(receivers: T.untyped).returns(T.untyped) }
  def walk(*receivers); end

  # Returns the value of attribute xobject.
  def xobject; end

  def xobjects(*args, &block); end

  private

  sig { returns(T.untyped) }
  def cached_tokens_key; end

  def callback(receivers, name, params = T.unsafe(nil)); end
  def content_stream(receivers, instructions); end

  sig { returns(T.untyped) }
  def content_stream_md5; end

  # Returns the resources that accompany this form.
  sig { returns(T.untyped) }
  def resources; end

  sig { returns(T.untyped) }
  def tokens; end
end

# A Hash-like object that can convert glyph names into a unicode codepoint.
# The mapping is read from a data file on disk the first time it's needed.
class PDF::Reader::GlyphHash
  # @return [GlyphHash] a new instance of GlyphHash
  sig { void }
  def initialize; end

  # attempt to convert a PDF Name to a unicode codepoint. Returns nil
  # if no conversion is possible.
  #
  #   h = GlyphHash.new
  #
  #   h.name_to_unicode(:A)
  #   => 65
  #
  #   h.name_to_unicode(:Euro)
  #   => 8364
  #
  #   h.name_to_unicode(:X4A)
  #   => 74
  #
  #   h.name_to_unicode(:G30)
  #   => 48
  #
  #   h.name_to_unicode(:34)
  #   => 34
  def name_to_unicode(name); end

  # attempt to convert a Unicode code point to the equivilant PDF Name. Returns nil
  # if no conversion is possible.
  #
  #   h = GlyphHash.new
  #
  #   h.unicode_to_name(65)
  #   => [:A]
  #
  #   h.unicode_to_name(8364)
  #   => [:Euro]
  #
  #   h.unicode_to_name(34)
  #   => [:34]
  def unicode_to_name(codepoint); end

  private

  # returns a hash that maps glyph names to unicode codepoints. The mapping is based on
  # a text file supplied by Adobe at:
  # https://github.com/adobe-type-tools/agl-aglfn
  sig { returns(T.untyped) }
  def load_adobe_glyph_mapping; end
end

# an exception that is raised when a PDF object appears to be invalid
class PDF::Reader::InvalidObjectError < ::PDF::Reader::MalformedPDFError; end

# an exception that is raised when an invalid page number is used
class PDF::Reader::InvalidPageError < ::ArgumentError; end

# Processes the Encrypt dict from an encrypted PDF and a user provided
# password and returns a key that can decrypt the file.
#
# This can generate a decryption key compatible with the following standard encryption algorithms:
#
# * Version 5 (AESV3)
class PDF::Reader::KeyBuilderV5
  # @return [KeyBuilderV5] a new instance of KeyBuilderV5
  def initialize(opts = T.unsafe(nil)); end

  # Takes a string containing a user provided password.
  #
  # If the password matches the file, then a string containing a key suitable for
  # decrypting the file will be returned. If the password doesn't match the file,
  # and exception will be raised.
  #
  # @raise [PDF::Reader::EncryptedPDFError]
  def key(pass); end

  private

  # Algorithm 3.2a - Computing an encryption key
  #
  # Defined in PDF 1.7 Extension Level 3
  #
  # if the string is a valid user/owner password, this will return the decryption key
  def auth_owner_pass(password); end

  def auth_owner_pass_r6(password); end
  def auth_user_pass(password); end
  def auth_user_pass_r6(password); end

  # PDF 2.0 spec, 7.6.4.3.4
  # Algorithm 2.B: Computing a hash (revision 6 and later)
  def r6_digest(password, salt, user_key = T.unsafe(nil)); end

  def unpack_128bit_bigendian_int(str); end
end

# A general class for decoding LZW compressed data. LZW can be
# used in PDF files to compresses streams, usually for image data sourced
# from a TIFF file.
#
# See the following links for more information:
#
#   ref http://www.fileformat.info/format/tiff/corion-lzw.htm
#   ref http://marknelson.us/1989/10/01/lzw-data-compression/
#
# The PDF spec also has some data on the algorithm.
class PDF::Reader::LZW
  class << self
    # Decompresses a LZW compressed string.
    def decode(data); end

    private

    # @raise [MalformedPDFError]
    def create_new_string(string_table, some_code, other_code); end
  end
end

# Wraps an LZW encoded string
class PDF::Reader::LZW::BitStream
  # @return [BitStream] a new instance of BitStream
  def initialize(data, bits_in_chunk); end

  sig { returns(Integer) }
  def read; end

  # @raise [MalformedPDFError]
  def set_bits_in_chunk(bits_in_chunk); end
end

# clear table
PDF::Reader::LZW::CODE_CLEAR_TABLE = T.let(T.unsafe(nil), Integer)

# end of data
PDF::Reader::LZW::CODE_EOD = T.let(T.unsafe(nil), Integer)

# stores de pairs code => string
class PDF::Reader::LZW::StringTable
  # @return [StringTable] a new instance of StringTable
  sig { void }
  def initialize; end

  # if code less than 258 return fixed string
  def [](key); end

  def add(string); end

  # Returns the value of attribute string_table_pos.
  def string_table_pos; end
end

# an exception that is raised when we believe the current PDF is not following
# the PDF spec and cannot be recovered
class PDF::Reader::MalformedPDFError < ::RuntimeError; end

# A null object security handler. Used when a PDF is unencrypted.
class PDF::Reader::NullSecurityHandler
  def decrypt(buf, _ref); end
end

# A Hash-like object for caching commonly used objects from a PDF file.
#
# This is an internal class, no promises about a stable API.
class PDF::Reader::ObjectCache
  # @return [ObjectCache] a new instance of ObjectCache
  def initialize(lru_size = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def each_key(&block); end

  def each_pair(&block); end

  sig { params(block: T.untyped).returns(T.untyped) }
  def each_value(&block); end

  # @return [Boolean]
  sig { returns(T.untyped) }
  def empty?; end

  def fetch(key, local_default = T.unsafe(nil)); end

  # @return [Boolean]
  def has_key?(key); end

  # @return [Boolean]
  def has_value?(value); end

  # Returns the value of attribute hits.
  def hits; end

  # @return [Boolean]
  def include?(key); end

  # @return [Boolean]
  def key?(key); end

  sig { returns(T.untyped) }
  def keys; end

  def length; end

  # @return [Boolean]
  def member?(key); end

  # Returns the value of attribute misses.
  def misses; end

  sig { returns(T.untyped) }
  def size; end

  sig { returns(T.untyped) }
  def to_s; end

  sig { returns(T.untyped) }
  def values; end

  private

  # @return [Boolean]
  def cacheable?(obj); end

  def update_stats(key); end
end

# These object types use little memory and are accessed a heap of times as
# part of random page access, so we'll cache the unmarshalled objects and
# avoid lots of repetitive (and expensive) tokenising
PDF::Reader::ObjectCache::CACHEABLE_TYPES = T.let(T.unsafe(nil), Array)

# Provides low level access to the objects in a PDF file via a hash-like
# object.
#
# A PDF file can be viewed as a large hash map. It is a series of objects
# stored at precise byte offsets, and a table that maps object IDs to byte
# offsets. Given an object ID, looking up an object is an O(1) operation.
#
# Each PDF object can be mapped to a ruby object, so by passing an object
# ID to the [] method, a ruby representation of that object will be
# retrieved.
#
# The class behaves much like a standard Ruby hash, including the use of
# the Enumerable mixin. The key difference is no []= method - the hash
# is read only.
#
# == Basic Usage
#
#     h = PDF::Reader::ObjectHash.new("somefile.pdf")
#     h[1]
#     => 3469
#
#     h[PDF::Reader::Reference.new(1,0)]
#     => 3469
class PDF::Reader::ObjectHash
  include ::Enumerable
  include Enumerable

  # Creates a new ObjectHash object. Input can be a string with a valid filename
  # or an IO-like object.
  #
  # Valid options:
  #
  #   :password - the user password to decrypt the source PDF
  #
  # @return [ObjectHash] a new instance of ObjectHash
  def initialize(input, opts = T.unsafe(nil)); end

  # Access an object from the PDF. key can be an int or a PDF::Reader::Reference
  # object.
  #
  # If an int is used, the object with that ID and a generation number of 0 will
  # be returned.
  #
  # If a PDF::Reader::Reference object is used the exact ID and generation number
  # can be specified.
  def [](key); end

  # Returns the value of attribute default.
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  def default=(_arg0); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  def deref(key); end

  # Recursively dereferences the object refered to be +key+. If +key+ is not
  # a PDF::Reader::Reference, the key is returned unchanged.
  def deref!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  def deref_array(key); end

  def deref_array!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Array of Numerics or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast array elements to a number is made for any non-numeric elements.
  #
  # @raise [MalformedPDFError]
  def deref_array_of_numbers(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a Hash or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  def deref_hash(key); end

  def deref_hash!(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return an Integer or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to an int is made when the reference points to a non-integer.
  def deref_integer(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF name (Symbol) or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to a symbol is made when the reference points to a non-symbol.
  def deref_name(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF Name (symbol), Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a Name or Array and no other type will do.
  def deref_name_or_array(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a Numeric or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting an Array and no other type will do.
  #
  # Some effort to cast to a number is made when the reference points to a non-number.
  def deref_number(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF::Reader::Stream or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a stream and no other type will do.
  def deref_stream(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a PDF::Reader::Stream, Array or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a stream or Array and no other type will do.
  def deref_stream_or_array(key); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  #
  # Guaranteed to only return a String or nil. If the dereference results in
  # any other type then a MalformedPDFError exception will raise. Useful when
  # expecting a string and no other type will do.
  #
  # Some effort to cast to a string is made when the reference points to a non-string.
  def deref_string(key); end

  # iterate over each key, value. Just like a ruby hash.
  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end

  # iterate over each key. Just like a ruby hash.
  sig { params(block: T.untyped).returns(T.untyped) }
  def each_key(&block); end

  # iterate over each key, value. Just like a ruby hash.
  def each_pair(&block); end

  # iterate over each value. Just like a ruby hash.
  sig { params(block: T.untyped).returns(T.untyped) }
  def each_value(&block); end

  # return true if there are no objects in this file
  #
  # @return [Boolean]
  sig { returns(T::Boolean) }
  def empty?; end

  # @return [Boolean]
  sig { returns(T::Boolean) }
  def encrypted?; end

  # Access an object from the PDF. key can be an int or a PDF::Reader::Reference
  # object.
  #
  # If an int is used, the object with that ID and a generation number of 0 will
  # be returned.
  #
  # If a PDF::Reader::Reference object is used the exact ID and generation number
  # can be specified.
  #
  # local_default is the object that will be returned if the requested key doesn't
  # exist.
  def fetch(key, local_default = T.unsafe(nil)); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  # @return [Boolean]
  def has_key?(check_key); end

  # return true if the specifiedvalue exists in the file
  #
  # @return [Boolean]
  def has_value?(value); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  # @return [Boolean]
  def include?(check_key); end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  # @return [Boolean]
  def key?(check_key); end

  # return an array of all keys in the file
  sig { returns(T::Array[PDF::Reader::Reference]) }
  def keys; end

  # return the number of objects in the file. An object with multiple generations
  # is counted once.
  def length; end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  # @return [Boolean]
  def member?(check_key); end

  # returns the type of object a ref points to
  def obj_type(ref); end

  # If key is a PDF::Reader::Reference object, lookup the corresponding
  # object in the PDF and return it. Otherwise return key untouched.
  def object(key); end

  # returns an array of PDF::Reader::References. Each reference in the
  # array points a Page object, one for each page in the PDF. The first
  # reference is page 1, second reference is page 2, etc.
  #
  # Useful for apps that want to extract data from specific pages.
  sig { returns(T::Array[PDF::Reader::Reference]) }
  def page_references; end

  # Returns the value of attribute pdf_version.
  def pdf_version; end

  # Returns the value of attribute sec_handler.
  def sec_handler; end

  # @return [Boolean]
  sig { returns(T::Boolean) }
  def sec_handler?; end

  # return the number of objects in the file. An object with multiple generations
  # is counted once.
  sig { returns(Integer) }
  def size; end

  # returns true if the supplied references points to an object with a stream
  #
  # @return [Boolean]
  def stream?(ref); end

  # return an array of arrays. Each sub array contains a key/value pair.
  sig { returns(T.untyped) }
  def to_a; end

  sig { returns(String) }
  def to_s; end

  # Returns the value of attribute trailer.
  def trailer; end

  # return true if the specified key exists in the file. key
  # can be an int or a PDF::Reader::Reference
  #
  # @return [Boolean]
  def value?(check_key); end

  # return an array of all values in the file
  sig { returns(T.untyped) }
  def values; end

  # return an array of all values from the specified keys
  sig { params(ids: T.untyped).returns(T.untyped) }
  def values_at(*ids); end

  private

  def decrypt(ref, obj); end

  # Private implementation of deref!, which exists to ensure the `seen` argument
  # isn't publicly available. It's used to avoid endless loops in the recursion, and
  # doesn't need to be part of the public API.
  def deref_internal!(key, seen); end

  def extract_io_from(input); end

  # parse a traditional object from the PDF, starting from the byte offset indicated
  # in the xref table
  def fetch_object(key); end

  # parse a object that's embedded in an object stream in the PDF
  def fetch_object_stream(key); end

  # returns an array of object references for all pages in this object store. The ordering of
  # the Array is significant and matches the page ordering of the document
  def get_page_objects(obj); end

  def new_buffer(offset = T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def object_streams; end

  def read_as_binary(input); end

  sig { returns(Float) }
  def read_version; end

  sig { returns(T.untyped) }
  def xref; end
end

# provides a wrapper around a PDF stream object that contains other objects in it.
# This is done for added compression and is described as an "Object Stream" in the spec.
class PDF::Reader::ObjectStream
  # @return [ObjectStream] a new instance of ObjectStream
  def initialize(stream); end

  def [](objid); end

  sig { returns(Integer) }
  def size; end

  private

  sig { returns(PDF::Reader::Buffer) }
  def buffer; end

  sig { returns(Integer) }
  def first; end

  sig { returns(T::Hash[Integer, Integer]) }
  def offsets; end
end

# remove duplicates from a collection of TextRun objects. This can be helpful when a PDF
# uses slightly offset overlapping characters to achieve a fake 'bold' effect.
class PDF::Reader::OverlappingRunsFilter
  class << self
    def detect_intersection(sweep_line_status, event_point); end
    def exclude_redundant_runs(runs); end
  end
end

# This should be between 0 and 1. If TextRun B obscures this much of TextRun A (and they
# have identical characters) then one will be discarded
PDF::Reader::OverlappingRunsFilter::OVERLAPPING_THRESHOLD = T.let(T.unsafe(nil), Float)

# high level representation of a single PDF page. Ties together the various
# low level classes in PDF::Reader and provides access to the various
# components of the page (text, images, fonts, etc) in convenient formats.
#
# If you require access to the raw PDF objects for this page, you can access
# the Page dictionary via the page_object accessor. You will need to use the
# objects accessor to help walk the page dictionary in any useful way.
class PDF::Reader::Page
  extend ::Forwardable

  # creates a new page wrapper.
  #
  # * objects - an ObjectHash instance that wraps a PDF file
  # * pagenum - an int specifying the page number to expose. 1 indexed.
  #
  # @return [Page] a new instance of Page
  def initialize(objects, pagenum, options = T.unsafe(nil)); end

  # Returns the attributes that accompany this page, including
  # attributes inherited from parents.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def attributes; end

  # returns the "boxes" that define the page object.
  # values are defaulted according to section 7.7.3.3 of the PDF Spec 1.7
  #
  # DEPRECATED. Recommend using Page#rectangles instead
  sig { returns(T::Hash[Symbol, T::Array[Numeric]]) }
  def boxes; end

  # a Hash-like object for storing cached data. Generally this is scoped to
  # the current document and is used to avoid repeating expensive
  # operations
  def cache; end

  def color_spaces(*args, &block); end
  def fonts(*args, &block); end
  def graphic_states(*args, &block); end

  sig { returns(Numeric) }
  def height; end

  # return a friendly string representation of this page
  sig { returns(String) }
  def inspect; end

  # return the number of this page within the full document
  sig { returns(Integer) }
  def number; end

  # lowlevel hash-like access to all objects in the underlying PDF
  def objects; end

  # Convenience method to identify the page's orientation.
  sig { returns(String) }
  def orientation; end

  sig { returns(T::Array[Numeric]) }
  def origin; end

  # the raw PDF object that defines this page
  def page_object; end

  def patterns(*args, &block); end
  def procedure_sets(*args, &block); end
  def properties(*args, &block); end

  # returns the raw content stream for this page. This is plumbing, nothing to
  # see here unless you're a PDF nerd like me.
  sig { returns(String) }
  def raw_content; end

  # returns the "boxes" that define the page object.
  # values are defaulted according to section 7.7.3.3 of the PDF Spec 1.7
  sig { returns(T::Hash[Symbol, PDF::Reader::Rectangle]) }
  def rectangles; end

  # returns the angle to rotate the page clockwise. Always 0, 90, 180 or 270
  sig { returns(Integer) }
  def rotate; end

  def runs(opts = T.unsafe(nil)); end
  def shadings(*args, &block); end

  # returns the plain text content of this page encoded as UTF-8. Any
  # characters that can't be translated will be returned as a ▯
  def text(opts = T.unsafe(nil)); end

  # returns the plain text content of this page encoded as UTF-8. Any
  # characters that can't be translated will be returned as a ▯
  def to_s(opts = T.unsafe(nil)); end

  # processes the raw content stream for this page in sequential order and
  # passes callbacks to the receiver objects.
  #
  # This is mostly low level and you can probably ignore it unless you need
  # access to something like the raw encoded text. For an example of how
  # this can be used as a basis for higher level functionality, see the
  # text() method
  #
  # If someone was motivated enough, this method is intended to provide all
  # the data required to faithfully render the entire page. If you find
  # some required data isn't available it's a bug - let me know.
  #
  # Many operators that generate callbacks will reference resources stored
  # in the page header - think images, fonts, etc. To facilitate these
  # operators, the first available callback is page=. If your receiver
  # accepts that callback it will be passed the current
  # PDF::Reader::Page object. Use the Page#resources method to grab any
  # required resources.
  #
  # It may help to think of each page as a self contained program made up of
  # a set of instructions and associated resources. Calling walk() executes
  # the program in the correct order and calls out to your implementation.
  sig { params(receivers: T.untyped).void }
  def walk(*receivers); end

  sig { returns(Numeric) }
  def width; end

  def xobjects(*args, &block); end

  private

  def ancestors(origin = T.unsafe(nil)); end

  # calls the name callback method on each receiver object with params as the arguments
  def callback(receivers, name, params = T.unsafe(nil)); end

  def content_stream(receivers, instructions); end

  sig { returns(T.untyped) }
  def page_with_ancestors; end

  # Returns the resources that accompany this page. Includes
  # resources inherited from parents.
  sig { returns(PDF::Reader::Resources) }
  def resources; end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def root; end

  # select the elements from a Pages dictionary that can be inherited by
  # child Page dictionaries.
  def select_inheritable(obj); end
end

# Takes a collection of TextRun objects and renders them into a single
# string that best approximates the way they'd appear on a render PDF page.
#
# media box should be a 4 number array that describes the dimensions of the
# page to be rendered as described by the page's MediaBox attribute
class PDF::Reader::PageLayout
  # @return [PageLayout] a new instance of PageLayout
  def initialize(runs, mediabox); end

  sig { params(chars: T::Array[PDF::Reader::TextRun]).returns(T::Array[PDF::Reader::TextRun]) }
  def group_chars_into_runs(chars); end

  sig { params(runs: T.untyped).returns(T.untyped) }
  def merge_runs(runs); end

  sig { returns(String) }
  def to_s; end

  private

  sig { returns(T.untyped) }
  def col_count; end

  sig { returns(T.untyped) }
  def col_multiplier; end

  # given an array of strings, return a new array with empty rows from the
  # beginning and end removed.
  #
  #   interesting_rows([ "", "one", "two", "" ])
  #   => [ "one", "two" ]
  def interesting_rows(rows); end

  def local_string_insert(haystack, needle, index); end
  def mean(collection); end
  def median(collection); end
  def page_height; end
  def page_width; end
  def process_mediabox(mediabox); end

  sig { returns(T.untyped) }
  def row_count; end

  sig { returns(T.untyped) }
  def row_multiplier; end
end

PDF::Reader::PageLayout::DEFAULT_FONT_SIZE = T.let(T.unsafe(nil), Integer)

# encapsulates logic for tracking graphics state as the instructions for
# a single page are processed. Most of the public methods correspond
# directly to PDF operators.
class PDF::Reader::PageState
  # starting a new page
  #
  # @return [PageState] a new instance of PageState
  def initialize(page); end

  # Text Object Operators
  sig { returns(T.untyped) }
  def begin_text_object; end

  # This returns a deep clone of the current state, ensuring changes are
  # keep separate from earlier states.
  #
  # Marshal is used to round-trip the state through a string to easily
  # perform the deep clone. Kinda hacky, but effective.
  sig { returns(T.untyped) }
  def clone_state; end

  # update the current transformation matrix.
  #
  # If the CTM is currently undefined, just store the new values.
  #
  # If there's an existing CTM, then multiply the existing matrix
  # with the new matrix to form the updated matrix.
  def concatenate_matrix(a, b, c, d, e, f); end

  # transform x and y co-ordinates from the current user space to the
  # underlying device space.
  def ctm_transform(x, y); end

  sig { returns(T.untyped) }
  def current_font; end

  sig { returns(T.untyped) }
  def end_text_object; end

  def find_color_space(label); end
  def find_font(label); end
  def find_xobject(label); end

  sig { returns(T.untyped) }
  def font_size; end

  # XObjects
  #
  # @raise [MalformedPDFError]
  def invoke_xobject(label); end

  # Text Positioning Operators
  def move_text_position(x, y); end

  # TD
  def move_text_position_and_set_leading(x, y); end

  # '
  def move_to_next_line_and_show_text(str); end

  # T*
  sig { returns(T.untyped) }
  def move_to_start_of_next_line; end

  # after each glyph is painted onto the page the text matrix must be
  # modified. There's no defined operator for this, but depending on
  # the use case some receivers may need to mutate the state with this
  # while walking a page.
  #
  # NOTE: some of the variable names in this method are obscure because
  #       they mirror variable names from the PDF spec
  #
  # NOTE: see Section 9.4.4, PDF 32000-1:2008, pp 252
  #
  # Arguments:
  #
  # w0 - the glyph width in *text space*. This generally means the width
  #      in glyph space should be divded by 1000 before being passed to
  #      this function
  # tj - any kerning that should be applied to the text matrix before the
  #      following glyph is painted. This is usually the numeric arguments
  #      in the array passed to a TJ operator
  # word_boundary - a boolean indicating if a word boundary was just
  #                 reached. Depending on the current state extra space
  #                 may need to be added
  def process_glyph_displacement(w0, tj, word_boundary); end

  # Restore the state to the previous value on the stack.
  sig { returns(T.untyped) }
  def restore_graphics_state; end

  # Clones the current graphics state and push it onto the top of the stack.
  # Any changes that are subsequently made to the state can then by reversed
  # by calling restore_graphics_state.
  sig { returns(T.untyped) }
  def save_graphics_state; end

  # Text State Operators
  def set_character_spacing(char_spacing); end

  def set_horizontal_text_scaling(h_scaling); end

  # "
  def set_spacing_next_line_show_text(aw, ac, string); end

  def set_text_font_and_size(label, size); end
  def set_text_leading(leading); end

  # Tm
  def set_text_matrix_and_text_line_matrix(a, b, c, d, e, f); end

  def set_text_rendering_mode(mode); end
  def set_text_rise(rise); end
  def set_word_spacing(word_spacing); end

  # Text Showing Operators
  def show_text_with_positioning(params); end

  # when save_graphics_state is called, we need to push a new copy of the
  # current state onto the stack. That way any modifications to the state
  # will be undone once restore_graphics_state is called.
  sig { returns(T.untyped) }
  def stack_depth; end

  # transform x and y co-ordinates from the current text space to the
  # underlying device space.
  #
  # transforming (0,0) is a really common case, so optimise for it to
  # avoid unnecessary object allocations
  def trm_transform(x, y); end

  private

  # wrap the raw PDF Font objects in handy ruby Font objects.
  def build_fonts(raw_fonts); end

  # return the current transformation matrix
  sig { returns(T.untyped) }
  def ctm; end

  # This class uses 3x3 matrices to represent geometric transformations
  # These matrices are represented by arrays with 9 elements
  # The array [a,b,c,d,e,f,g,h,i] would represent a matrix like:
  #   a b c
  #   d e f
  #   g h i
  sig { returns(T.untyped) }
  def identity_matrix; end

  sig { returns(T.untyped) }
  def state; end

  # used for many and varied text positioning calculations. We potentially
  # need to access the results of this method many times when working with
  # text, so memoize it
  sig { returns(T.untyped) }
  def text_rendering_matrix; end
end

PDF::Reader::PageState::DEFAULT_GRAPHICS_STATE = T.let(T.unsafe(nil), Hash)

# Builds a UTF-8 string of all the text on a single page by processing all
# the operaters in a content stream.
class PDF::Reader::PageTextReceiver
  extend ::Forwardable
  extend Forwardable

  def begin_text_object(*args, &block); end
  def concatenate_matrix(*args, &block); end

  # deprecated
  sig { returns(T.untyped) }
  def content; end

  def end_text_object(*args, &block); end
  def font_size(*args, &block); end

  # XObjects
  def invoke_xobject(label); end

  def move_text_position(*args, &block); end
  def move_text_position_and_set_leading(*args, &block); end

  # '
  def move_to_next_line_and_show_text(str); end

  def move_to_start_of_next_line(*args, &block); end

  # Returns the value of attribute options.
  def options; end

  # starting a new page
  def page=(page); end

  def restore_graphics_state(*args, &block); end
  def runs(opts = T.unsafe(nil)); end
  def save_graphics_state(*args, &block); end
  def set_character_spacing(*args, &block); end
  def set_horizontal_text_scaling(*args, &block); end

  # "
  def set_spacing_next_line_show_text(aw, ac, string); end

  def set_text_font_and_size(*args, &block); end
  def set_text_leading(*args, &block); end
  def set_text_matrix_and_text_line_matrix(*args, &block); end
  def set_text_rendering_mode(*args, &block); end
  def set_text_rise(*args, &block); end
  def set_word_spacing(*args, &block); end

  # Text Showing Operators
  #
  # record text that is drawn on the page
  def show_text(string); end

  # TJ [(A) 120 (WA) 20 (Y)]
  def show_text_with_positioning(params); end

  # Returns the value of attribute state.
  def state; end

  private

  def apply_rotation(x, y); end
  def group_chars_into_runs(chars); end
  def internal_show_text(string); end

  # take a collection of TextRun objects and merge any that are in close
  # proximity
  def merge_runs(runs); end
end

PDF::Reader::PageTextReceiver::SPACE = T.let(T.unsafe(nil), String)

# == Text Callbacks
#
# - end_text_object
# - move_to_start_of_next_line
# - set_character_spacing
# - move_text_position
# - move_text_position_and_set_leading
# - set_text_font_and_size
# - show_text
# - show_text_with_positioning
# - set_text_leading
# - set_text_matrix_and_text_line_matrix
# - set_text_rendering_mode
# - set_text_rise
# - set_word_spacing
# - set_horizontal_text_scaling
# - move_to_next_line_and_show_text
# - set_spacing_next_line_show_text
#
# == Graphics Callbacks
# - close_fill_stroke
# - fill_stroke
# - close_fill_stroke_with_even_odd
# - fill_stroke_with_even_odd
# - begin_marked_content_with_pl
# - begin_inline_image
# - begin_marked_content
# - begin_text_object
# - append_curved_segment
# - concatenate_matrix
# - set_stroke_color_space
# - set_nonstroke_color_space
# - set_line_dash
# - set_glyph_width
# - set_glyph_width_and_bounding_box
# - invoke_xobject
# - define_marked_content_with_pl
# - end_inline_image
# - end_marked_content
# - fill_path_with_nonzero
# - fill_path_with_nonzero
# - fill_path_with_even_odd
# - set_gray_for_stroking
# - set_gray_for_nonstroking
# - set_graphics_state_parameters
# - close_subpath
# - set_flatness_tolerance
# - begin_inline_image_data
# - set_line_join_style
# - set_line_cap_style
# - set_cmyk_color_for_stroking,
# - set_cmyk_color_for_nonstroking
# - append_line
# - begin_new_subpath
# - set_miter_limit
# - define_marked_content_point
# - end_path
# - save_graphics_state
# - restore_graphics_state
# - append_rectangle
# - set_rgb_color_for_stroking
# - set_rgb_color_for_nonstroking
# - set_color_rendering_intent
# - close_and_stroke_path
# - stroke_path
# - set_color_for_stroking
# - set_color_for_nonstroking
# - set_color_for_stroking_and_special
# - set_color_for_nonstroking_and_special
# - paint_area_with_shading_pattern
# - append_curved_segment_initial_point_replicated
# - set_line_width
# - set_clipping_path_with_nonzero
# - set_clipping_path_with_even_odd
# - append_curved_segment_final_point_replicated
class PDF::Reader::PagesStrategy; end

PDF::Reader::PagesStrategy::OPERATORS = T.let(T.unsafe(nil), Hash)

# An internal PDF::Reader class that reads objects from the PDF file and converts
# them into useable ruby objects (hash's, arrays, true, false, etc)
class PDF::Reader::Parser
  # Create a new parser around a PDF::Reader::Buffer object
  #
  # buffer - a PDF::Reader::Buffer object that contains PDF data
  # objects  - a PDF::Reader::ObjectHash object that can return objects from the PDF file
  #
  # @return [Parser] a new instance of Parser
  def initialize(buffer, objects = T.unsafe(nil)); end

  # Reads an entire PDF object from the buffer and returns it as a Ruby String.
  # If the object is a content stream, returns both the stream and the dictionary
  # that describes it
  #
  # id  - the object ID to return
  # gen - the object revision number to return
  def object(id, gen); end

  # Reads the next token from the underlying buffer and convets it to an appropriate
  # object
  #
  # operators - a hash of supported operators to read from the underlying buffer.
  def parse_token(operators = T.unsafe(nil)); end

  private

  # reads a PDF array from the buffer and converts it to a Ruby Array.
  sig { returns(T::Array[T.untyped]) }
  def array; end

  # reads a PDF dict from the buffer and converts it to a Ruby Hash.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def dictionary; end

  # Reads a PDF hex string from the buffer and converts it to a Ruby String
  sig { returns(String) }
  def hex_string; end

  # reads a PDF name from the buffer and converts it to a Ruby Symbol
  sig { returns(Symbol) }
  def pdf_name; end

  # Decodes the contents of a PDF Stream and returns it as a Ruby String.
  #
  # @raise [MalformedPDFError]
  def stream(dict); end

  # Reads a PDF String from the buffer and converts it to a Ruby String
  sig { returns(String) }
  def string; end
end

PDF::Reader::Parser::MAPPING = T.let(T.unsafe(nil), Hash)
PDF::Reader::Parser::STRATEGIES = T.let(T.unsafe(nil), Hash)
PDF::Reader::Parser::TOKEN_STRATEGY = T.let(T.unsafe(nil), Proc)

# PDFs are all about positioning content on a page, so there's lots of need to
# work with a set of X,Y coordinates.
class PDF::Reader::Point
  # @return [Point] a new instance of Point
  def initialize(x, y); end

  def ==(other); end

  # Returns the value of attribute x.
  sig { returns(Numeric) }
  def x; end

  # Returns the value of attribute y.
  sig { returns(Numeric) }
  def y; end
end

# A simple receiver that prints all operaters and parameters in the content
# stream of a single page.
class PDF::Reader::PrintReceiver
  # @return [PrintReceiver] a new instance of PrintReceiver
  sig { void }
  def initialize; end

  # Returns the value of attribute callbacks.
  def callbacks; end

  # Sets the attribute callbacks
  #
  # @param value the value to set the attribute callbacks to.
  def callbacks=(_arg0); end

  def method_missing(methodname, *args); end

  # @return [Boolean]
  def respond_to?(meth); end
end

# Decrypts data using the RC4 algorithim defined in the PDF spec. Requires
# a decryption key, which is usually generated by PDF::Reader::StandardKeyBuilder
class PDF::Reader::Rc4SecurityHandler
  # @return [Rc4SecurityHandler] a new instance of Rc4SecurityHandler
  def initialize(key); end

  # 7.6.2 General Encryption Algorithm
  #
  # Algorithm 1: Encryption of data using the RC4 algorithm
  #
  # version <=3 or (version == 4 and CFM == V2)
  #
  # buf - a string to decrypt
  # ref - a PDF::Reader::Reference for the object to decrypt
  def decrypt(buf, ref); end
end

# PDFs represent rectangles all over the place. They're 4 element arrays, like this:
#
#     [A, B, C, D]
#
# Four element arrays are yucky to work with though, so here's a class that's better.
# Initialize it with the 4 elements, and get utility functions (width, height, etc)
# for free.
#
# By convention the first two elements are x1, y1, the co-ords for the bottom left corner
# of the rectangle. The third and fourth elements are x2, y2, the co-ords for the top left
# corner of the rectangle. It's valid for the alternative corners to be used though, so
# we don't assume which is which.
class PDF::Reader::Rectangle
  # @return [Rectangle] a new instance of Rectangle
  def initialize(x1, y1, x2, y2); end

  def ==(other); end
  def apply_rotation(degrees); end

  # Returns the value of attribute bottom_left.
  sig { returns(PDF::Reader::Point) }
  def bottom_left; end

  # Returns the value of attribute bottom_right.
  sig { returns(PDF::Reader::Point) }
  def bottom_right; end

  # @return [Boolean]
  def contains?(point); end

  sig { returns(Numeric) }
  def height; end

  # A pdf-style 4-number array
  sig { returns(T::Array[Numeric]) }
  def to_a; end

  # Returns the value of attribute top_left.
  sig { returns(PDF::Reader::Point) }
  def top_left; end

  # Returns the value of attribute top_right.
  sig { returns(PDF::Reader::Point) }
  def top_right; end

  sig { returns(Numeric) }
  def width; end

  private

  def set_corners(x1, y1, x2, y2); end

  class << self
    def from_array(arr); end
  end
end

# An internal PDF::Reader class that represents an indirect reference to a PDF Object
class PDF::Reader::Reference
  # Create a new Reference to an object with the specified id and revision number
  #
  # @return [Reference] a new instance of Reference
  def initialize(id, gen); end

  # returns true if the provided object points to the same PDF Object as the
  # current object
  def ==(obj); end

  # returns true if the provided object points to the same PDF Object as the
  # current object
  def eql?(obj); end

  # Returns the value of attribute gen.
  def gen; end

  # returns a hash based on the PDF::Reference this object points to. Two
  # different Reference objects that point to the same PDF Object will
  # return an identical hash
  sig { returns(T.untyped) }
  def hash; end

  # Returns the value of attribute id.
  def id; end

  # returns the current Reference object in an array with a single element
  sig { returns(T.untyped) }
  def to_a; end

  # returns the ID of this reference. Use with caution, ignores the generation id
  sig { returns(T.untyped) }
  def to_i; end
end

# An example receiver that just records all callbacks generated by parsing
# a PDF file.
#
# Useful for testing the contents of a file in an rspec/test-unit suite.
#
# Usage:
#
#     PDF::Reader.open("somefile.pdf") do |reader|
#       receiver = PDF::Reader::RegisterReceiver.new
#       reader.page(1).walk(receiver)
#       callback = receiver.first_occurance_of(:show_text)
#       callback[:args].first.should == "Hellow World"
#     end
class PDF::Reader::RegisterReceiver
  # @return [RegisterReceiver] a new instance of RegisterReceiver
  sig { void }
  def initialize; end

  # return the details for every time the specified callback was fired
  def all(methodname); end

  def all_args(methodname); end

  # Returns the value of attribute callbacks.
  def callbacks; end

  # Sets the attribute callbacks
  #
  # @param value the value to set the attribute callbacks to.
  def callbacks=(_arg0); end

  # count the number of times a callback fired
  def count(methodname); end

  # return the details for the final time the specified callback was fired
  def final_occurance_of(methodname); end

  # return the details for the first time the specified callback was fired
  def first_occurance_of(methodname); end

  def method_missing(methodname, *args); end

  # @return [Boolean]
  def respond_to?(meth); end

  # return the first occurance of a particular series of callbacks
  sig { params(methods: T.untyped).returns(T.untyped) }
  def series(*methods); end
end

# mixin for common methods in Page and FormXobjects
class PDF::Reader::Resources
  # @return [Resources] a new instance of Resources
  def initialize(objects, resources); end

  # Returns a Hash of color spaces that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def color_spaces; end

  # Returns a Hash of fonts that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def fonts; end

  # Returns a Hash of external graphic states that are available to this
  # page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def graphic_states; end

  # Returns a Hash of patterns that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def patterns; end

  # Returns an Array of procedure sets that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Array[Symbol]) }
  def procedure_sets; end

  # Returns a Hash of properties sets that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def properties; end

  # Returns a Hash of shadings that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, T.untyped]) }
  def shadings; end

  # Returns a Hash of XObjects that are available to this page
  #
  # NOTE: this method de-serialise objects from the underlying PDF
  #       with no caching. You will want to cache the results instead
  #       of calling it over and over.
  sig { returns(T::Hash[Symbol, PDF::Reader::Stream]) }
  def xobjects; end
end

# Examines the Encrypt entry of a PDF trailer (if any) and returns an object that's
# able to decrypt the file.
class PDF::Reader::SecurityHandlerFactory
  class << self
    def build(encrypt, doc_id, password); end
    def build_standard_handler(encrypt, doc_id, password); end
    def build_v5_handler(encrypt, doc_id, password); end

    # This handler supports all encryption that follows upto PDF 1.5 spec (revision 4)
    #
    # @return [Boolean]
    def standard?(encrypt); end

    # This handler supports both
    # - AES-256 encryption defined in PDF 1.7 Extension Level 3 ('revision 5')
    # - AES-256 encryption defined in PDF 2.0 ('revision 6')
    #
    # @return [Boolean]
    def standard_v5?(encrypt); end
  end
end

# Processes the Encrypt dict from an encrypted PDF and a user provided
# password and returns a key that can decrypt the file.
#
# This can generate a key compatible with the following standard encryption algorithms:
#
# * Version 1-3, all variants
# * Version 4, V2 (RC4) and AESV2
class PDF::Reader::StandardKeyBuilder
  # @return [StandardKeyBuilder] a new instance of StandardKeyBuilder
  def initialize(opts = T.unsafe(nil)); end

  # Takes a string containing a user provided password.
  #
  # If the password matches the file, then a string containing a key suitable for
  # decrypting the file will be returned. If the password doesn't match the file,
  # and exception will be raised.
  #
  # @raise [PDF::Reader::EncryptedPDFError]
  def key(pass); end

  private

  # 7.6.3.4 Password Algorithms
  #
  # Algorithm 7 - Authenticating the Owner Password
  #
  # Used to test Owner passwords
  #
  # if the string is a valid owner password this will return the user
  # password that should be used to decrypt the document.
  #
  # if the supplied password is not a valid owner password for this document
  # then it returns nil
  def auth_owner_pass(pass); end

  # Algorithm 6 - Authenticating the User Password
  #
  # Used to test User passwords
  #
  # if the string is a valid user password this will return the user
  # password that should be used to decrypt the document.
  #
  # if the supplied password is not a valid user password for this document
  # then it returns nil
  def auth_user_pass(pass); end

  def make_file_key(user_pass); end

  # Pads supplied password to 32bytes using PassPadBytes as specified on
  # pp61 of spec
  def pad_pass(p = T.unsafe(nil)); end

  def xor_each_byte(buf, int); end
end

# 7.6.3.3 Encryption Key Algorithm (pp61)
#
# needs a document's user password to build a key for decrypting an
# encrypted PDF document
PDF::Reader::StandardKeyBuilder::PassPadBytes = T.let(T.unsafe(nil), Array)

# An internal PDF::Reader class that represents a stream object from a PDF. Stream
# objects have 2 components, a dictionary that describes the content (size,
# compression, etc) and a stream of bytes.
class PDF::Reader::Stream
  # Creates a new stream with the specified dictionary and data. The dictionary
  # should be a standard ruby hash, the data should be a standard ruby string.
  #
  # @return [Stream] a new instance of Stream
  def initialize(hash, data); end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # Returns the value of attribute hash.
  def hash; end

  # Sets the attribute hash
  #
  # @param value the value to set the attribute hash to.
  def hash=(_arg0); end

  # apply this streams filters to its data and return the result.
  sig { returns(String) }
  def unfiltered_data; end
end

# Throughout the pdf-reader codebase, repeated calculations which can benefit
# from caching are made In some cases, caching and reusing results can not
# only save CPU cycles but also greatly reduce memory requirements But at the
# same time, we don't want to throw away thread safety We have two
# interchangeable thread-safe cache implementations:
class PDF::Reader::SynchronizedCache
  # @return [SynchronizedCache] a new instance of SynchronizedCache
  sig { void }
  def initialize; end

  def [](key); end
  def []=(key, value); end
end

# A value object that represents one or more consecutive characters on a page.
class PDF::Reader::TextRun
  include ::Comparable
  include Comparable

  # @return [TextRun] a new instance of TextRun
  def initialize(x, y, width, font_size, text); end

  # @raise [ArgumentError]
  def +(other); end

  # Allows collections of TextRun objects to be sorted. They will be sorted
  # in order of their position on a cartesian plain - Top Left to Bottom Right
  def <=>(other); end

  sig { returns(T.untyped) }
  def endx; end

  sig { returns(T.untyped) }
  def endy; end

  # Returns the value of attribute font_size.
  def font_size; end

  sig { returns(T.untyped) }
  def inspect; end

  # @return [Boolean]
  def intersect?(other_run); end

  # return what percentage of this text run is overlapped by another run
  def intersection_area_percent(other_run); end

  sig { returns(T.untyped) }
  def mean_character_width; end

  # @return [Boolean]
  def mergable?(other); end

  # Returns the value of attribute origin.
  def origin; end

  # Returns the value of attribute text.
  def text; end

  # Returns the value of attribute text.
  def to_s; end

  # Returns the value of attribute width.
  def width; end

  def x; end
  def y; end

  private

  sig { returns(T.untyped) }
  def area; end

  # Assume string encoding is marked correctly and we can trust String#size to return a
  # character count
  sig { returns(T.untyped) }
  def character_count; end

  sig { returns(T.untyped) }
  def mergable_range; end
end

# An internal PDF::Reader class that represents a single token from a PDF file.
#
# Behaves exactly like a Ruby String - it basically exists for convenience.
class PDF::Reader::Token < ::String
  # Creates a new token with the specified value
  #
  # @return [Token] a new instance of Token
  def initialize(val); end
end

# co-ordinate systems in PDF files are specified using a 3x3 matrix that looks
# something like this:
#
#   [ a b 0 ]
#   [ c d 0 ]
#   [ e f 1 ]
#
# Because the final column never changes, we can represent each matrix using
# only 6 numbers. This is important to save CPU time, memory and GC pressure
# caused by allocating too many unnecessary objects.
class PDF::Reader::TransformationMatrix
  # @return [TransformationMatrix] a new instance of TransformationMatrix
  def initialize(a, b, c, d, e, f); end

  # Returns the value of attribute a.
  def a; end

  # Returns the value of attribute b.
  def b; end

  # Returns the value of attribute c.
  def c; end

  # Returns the value of attribute d.
  def d; end

  # Returns the value of attribute e.
  def e; end

  # Returns the value of attribute f.
  def f; end

  # Optimised method for when the second matrix in the calculation is
  # a simple horizontal displacement.
  #
  # Like this:
  #
  #   [ 1 2 0 ]   [ 1  0 0 ]
  #   [ 3 4 0 ] x [ 0  1 0 ]
  #   [ 5 6 1 ]   [ e2 0 1 ]
  def horizontal_displacement_multiply!(e2); end

  sig { returns(T.untyped) }
  def inspect; end

  # multiply this matrix with another.
  #
  # the second matrix is represented by the 6 scalar values that are changeable
  # in a PDF transformation matrix.
  #
  # WARNING: This mutates the current matrix to avoid allocating memory when
  #          we don't need too. Matrices are multiplied ALL THE FREAKING TIME
  #          so this is a worthwhile optimisation
  #
  # NOTE: When multiplying matrices, ordering matters. Double check
  #       the PDF spec to ensure you're multiplying things correctly.
  #
  # NOTE: see Section 8.3.3, PDF 32000-1:2008, pp 119
  #
  # NOTE: The if statements in this method are ordered to prefer optimisations
  #       that allocate fewer objects
  #
  # TODO: it might be worth adding an optimised path for vertical
  #       displacement to speed up processing documents that use vertical
  #       writing systems
  def multiply!(a, b = T.unsafe(nil), c = T.unsafe(nil), d = T.unsafe(nil), e = T.unsafe(nil), f = T.unsafe(nil)); end

  sig { returns(T.untyped) }
  def to_a; end

  private

  # A general solution for multiplying two matrices when we know all values
  # in the final column are fixed. This is the fallback method for when none
  # of the optimised methods are applicable.
  #
  # Like this:
  #
  #   [ a b 0 ]   [ a b 0 ]
  #   [ c d 0 ] x [ c d 0 ]
  #   [ e f 1 ]   [ e f 1 ]
  def faster_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the first matrix in the calculation is
  # a simple horizontal displacement.
  #
  # Like this:
  #
  #   [ 1 0 0 ]   [ 1 2 0 ]
  #   [ 0 1 0 ] x [ 3 4 0 ]
  #   [ 5 0 1 ]   [ 5 6 1 ]
  def horizontal_displacement_multiply_reversed!(a2, b2, c2, d2, e2, f2); end

  # A general solution to multiplying two 3x3 matrixes. This is correct in all cases,
  # but slower due to excessive object allocations. It's not actually used in any
  # active code paths, but is here for reference. Use faster_multiply instead.
  #
  # Like this:
  #
  #   [ a b 0 ]   [ a b 0 ]
  #   [ c d 0 ] x [ c d 0 ]
  #   [ e f 1 ]   [ e f 1 ]
  def regular_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the second matrix in the calculation is
  # an X and Y scale
  #
  # Like this:
  #
  #   [ 1 2 0 ]   [ 5 0 0 ]
  #   [ 3 4 0 ] x [ 0 5 0 ]
  #   [ 5 6 1 ]   [ 0 0 1 ]
  def xy_scaling_multiply!(a2, b2, c2, d2, e2, f2); end

  # Optimised method for when the first matrix in the calculation is
  # an X and Y scale
  #
  # Like this:
  #
  #   [ 5 0 0 ]   [ 1 2 0 ]
  #   [ 0 5 0 ] x [ 3 4 0 ]
  #   [ 0 0 1 ]   [ 5 6 1 ]
  def xy_scaling_multiply_reversed!(a2, b2, c2, d2, e2, f2); end
end

# Cast untrusted input (usually parsed out of a PDF file) to a known type
class PDF::Reader::TypeCheck
  class << self
    def cast_to_int!(obj); end
    def cast_to_numeric!(obj); end
    def cast_to_pdf_dict!(obj); end
    def cast_to_pdf_dict_with_stream_values!(obj); end
    def cast_to_string!(string); end
    def cast_to_symbol(obj); end
    def cast_to_symbol!(obj); end
  end
end

# Security handler for when we don't support the flavour of encryption
# used in a PDF.
class PDF::Reader::UnimplementedSecurityHandler
  # @raise [PDF::Reader::EncryptedPDFError]
  def decrypt(buf, ref); end

  class << self
    # @return [Boolean]
    def supports?(encrypt); end
  end
end

# an exception that is raised when a PDF follows the specs but uses a feature
# that we don't support just yet
class PDF::Reader::UnsupportedFeatureError < ::RuntimeError; end

# Page#walk will execute the content stream of a page, calling methods on a receiver class
# provided by the user. Each operator has a specific set of parameters it expects, and we
# wrap the users receiver class in this one to verify the PDF uses valid parameters.
#
# Without these checks, users can't be confident about the number of parameters they'll receive
# for an operator, or what the type of those parameters will be. Everyone ends up building their
# own type safety guard clauses and it's tedious.
#
# Not all operators have type safety implemented yet, but we can expand the number over time.
class PDF::Reader::ValidatingReceiver
  # @return [ValidatingReceiver] a new instance of ValidatingReceiver
  def initialize(wrapped); end

  # Inline Image Operators
  sig { params(args: T.untyped).void }
  def begin_inline_image(*args); end

  sig { params(args: T.untyped).void }
  def begin_inline_image_data(*args); end

  # Text Object Operators
  sig { params(args: T.untyped).void }
  def begin_text_object(*args); end

  # Matrix Operators
  sig { params(args: T.untyped).void }
  def concatenate_matrix(*args); end

  sig { params(args: T.untyped).void }
  def end_inline_image(*args); end

  sig { params(args: T.untyped).void }
  def end_text_object(*args); end

  # Form XObject Operators
  sig { params(args: T.untyped).void }
  def invoke_xobject(*args); end

  def method_missing(methodname, *args); end

  # Text Positioning Operators
  sig { params(args: T.untyped).void }
  def move_text_position(*args); end

  # TD
  sig { params(args: T.untyped).void }
  def move_text_position_and_set_leading(*args); end

  # '
  sig { params(args: T.untyped).void }
  def move_to_next_line_and_show_text(*args); end

  # T*
  sig { params(args: T.untyped).void }
  def move_to_start_of_next_line(*args); end

  def page=(page); end

  # Final safety net for any operators that don't have type checking enabled yet
  #
  # @return [Boolean]
  def respond_to?(meth); end

  sig { params(args: T.untyped).void }
  def restore_graphics_state(*args); end

  # Graphics State Operators
  sig { params(args: T.untyped).void }
  def save_graphics_state(*args); end

  # Text State Operators
  sig { params(args: T.untyped).void }
  def set_character_spacing(*args); end

  sig { params(args: T.untyped).void }
  def set_horizontal_text_scaling(*args); end

  # "
  sig { params(args: T.untyped).void }
  def set_spacing_next_line_show_text(*args); end

  sig { params(args: T.untyped).void }
  def set_text_font_and_size(*args); end

  sig { params(args: T.untyped).void }
  def set_text_leading(*args); end

  # Tm
  sig { params(args: T.untyped).void }
  def set_text_matrix_and_text_line_matrix(*args); end

  sig { params(args: T.untyped).void }
  def set_text_rendering_mode(*args); end

  sig { params(args: T.untyped).void }
  def set_text_rise(*args); end

  sig { params(args: T.untyped).void }
  def set_word_spacing(*args); end

  # Text Showing Operators
  sig { params(args: T.untyped).void }
  def show_text(*args); end

  # TJ [(A) 120 (WA) 20 (Y)]
  sig { params(args: T.untyped).void }
  def show_text_with_positioning(*args); end

  private

  def call_wrapped(methodname, *args); end
end

module PDF::Reader::WidthCalculator; end

# Type1 fonts can be one of 14 "built in" standard fonts. In these cases,
# the reader is expected to have it's own copy of the font metrics.
# see Section 9.6.2.2, PDF 32000-1:2008, pp 256
class PDF::Reader::WidthCalculator::BuiltIn
  # @return [BuiltIn] a new instance of BuiltIn
  def initialize(font); end

  def glyph_width(code_point); end

  private

  # @return [Boolean]
  def control_character?(code_point); end

  def extract_basefont(font_name); end
end

PDF::Reader::WidthCalculator::BuiltIn::BUILTINS = T.let(T.unsafe(nil), Array)

# CIDFontType0 or CIDFontType2 use DW (integer) and W (array) to determine
# codepoint widths, note that CIDFontType2 will contain a true type font
# program which could be used to calculate width, however, a conforming writer
# is supposed to convert the widths for the codepoints used into the W array
# so that it can be used.
# see Section 9.7.4.1, PDF 32000-1:2008, pp 269-270
class PDF::Reader::WidthCalculator::Composite
  # @return [Composite] a new instance of Composite
  def initialize(font); end

  def glyph_width(code_point); end
end

# Calculates the width of a glyph in a TrueType font
class PDF::Reader::WidthCalculator::TrueType
  # @return [TrueType] a new instance of TrueType
  def initialize(font); end

  def glyph_width(code_point); end

  private

  def glyph_width_from_descriptor(code_point); end

  # TODO convert Type3 units 1000 units => 1 text space unit
  def glyph_width_from_font(code_point); end
end

# Calculates the width of a glyph in a Type One or Type Three
class PDF::Reader::WidthCalculator::TypeOneOrThree
  # @return [TypeOneOrThree] a new instance of TypeOneOrThree
  def initialize(font); end

  def glyph_width(code_point); end
end

# Type0 (or Composite) fonts are a "root font" that rely on a "descendant font"
# to do the heavy lifting. The "descendant font" is a CID-Keyed font.
# see Section 9.7.1, PDF 32000-1:2008, pp 267
# so if we are calculating a Type0 font width, we just pass off to
# the descendant font
class PDF::Reader::WidthCalculator::TypeZero
  # @return [TypeZero] a new instance of TypeZero
  def initialize(font); end

  def glyph_width(code_point); end
end

# An internal PDF::Reader class that represents the XRef table in a PDF file as a
# hash-like object.
#
# An Xref table is a map of object identifiers and byte offsets. Any time a particular
# object needs to be found, the Xref table is used to find where it is stored in the
# file.
#
# Hash keys are object ids, values are either:
#
# * a byte offset where the object starts (regular PDF objects)
# * a PDF::Reader::Reference instance that points to a stream that contains the
#   desired object (PDF objects embedded in an object stream)
#
# The class behaves much like a standard Ruby hash, including the use of
# the Enumerable mixin. The key difference is no []= method - the hash
# is read only.
class PDF::Reader::XRef
  include ::Enumerable
  include Enumerable

  # create a new Xref table based on the contents of the supplied io object
  #
  # io - must be an IO object, generally either a file or a StringIO
  #
  # @return [XRef] a new instance of XRef
  def initialize(io); end

  # returns the byte offset for the specified PDF object.
  #
  # ref - a PDF::Reader::Reference object containing an object ID and revision number
  def [](ref); end

  # iterate over each object in the xref table
  sig { params(block: T.untyped).returns(T.untyped) }
  def each(&block); end

  # return the number of objects in this file. Objects with multiple generations are
  # only counter once.
  sig { returns(T.untyped) }
  def size; end

  # Returns the value of attribute trailer.
  def trailer; end

  private

  # Returns the offset of the PDF document in the +stream+. In theory this
  # should always be 0, but all sort of crazy junk is prefixed to PDF files
  # in the real world.
  #
  # Checks up to 1024 chars into the file,
  # returns nil if no PDF data detected.
  # Adobe PDF 1.4 spec (3.4.1) 12. Acrobat viewers require only that the
  # header appear somewhere within the first 1024 bytes of the file
  def calc_junk_offset(io); end

  # Read a xref table from the underlying buffer.
  #
  # If offset is specified the table will be loaded from there, otherwise the
  # default offset will be located and used.
  #
  # After seeking to the offset, processing is handed of to either load_xref_table()
  # or load_xref_stream() based on what we find there.
  #
  # @raise [PDF::Reader::MalformedPDFError]
  def load_offsets(offset = T.unsafe(nil)); end

  # Read an XRef stream from the underlying buffer instead of a traditional xref table.
  def load_xref_stream(stream); end

  # Assumes the underlying buffer is positioned at the start of a traditional
  # Xref table and processes it into memory.
  def load_xref_table(buf); end

  # Wrap the io stream we're working with in a buffer that can tokenise it for us.
  #
  # We create multiple buffers so we can be tokenising multiple sections of the file
  # at the same time without worrying about clearing the buffers contents.
  def new_buffer(offset = T.unsafe(nil)); end

  # Stores an offset value for a particular PDF object ID and revision number
  def store(id, gen, offset); end

  # XRef streams pack info into integers 1-N bytes wide. Depending on the number of
  # bytes they need to be converted to an int in different ways.
  def unpack_bytes(bytes); end
end

# There's no point rendering zero-width characters
class PDF::Reader::ZeroWidthRunsFilter
  class << self
    def exclude_zero_width_runs(runs); end
  end
end
