# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ethon` gem.
# Please instead update this file by running `bin/tapioca gem ethon`.

module Ethon
  extend ::Ethon::Loggable
end

module Ethon::Curl
  extend ::FFI::Library
  extend ::Ethon::Curls::Codes
  extend ::Ethon::Curls::Options
  extend ::Ethon::Curls::Infos
  extend ::Ethon::Curls::FormOptions
  extend ::Ethon::Curls::Messages
  extend ::Ethon::Curls::Functions

  def easy_cleanup(*_arg0); end
  def easy_duphandle(*_arg0); end
  def easy_escape(*_arg0); end
  def easy_getinfo(*args); end
  def easy_init(*_arg0); end
  def easy_perform(*_arg0); end
  def easy_reset(*_arg0); end
  def easy_setopt(*args); end
  def easy_strerror(*_arg0); end
  def formadd(*args); end
  def formfree(*_arg0); end
  def free(*_arg0); end
  def global_cleanup(*_arg0); end
  def global_init(*_arg0); end
  def multi_add_handle(*_arg0); end
  def multi_cleanup(*_arg0); end
  def multi_fdset(*_arg0); end
  def multi_info_read(*_arg0); end
  def multi_init(*_arg0); end
  def multi_perform(*_arg0); end
  def multi_remove_handle(*_arg0); end
  def multi_setopt(*args); end
  def multi_socket_action(*_arg0); end
  def multi_strerror(*_arg0); end
  def multi_timeout(*_arg0); end
  def select(*_arg0); end
  def slist_append(*_arg0); end
  def slist_free_all(*_arg0); end
  def version(*_arg0); end
  def version_info(*_arg0); end

  class << self
    def cleanup; end
    def easy_cleanup(*_arg0); end
    def easy_duphandle(*_arg0); end
    def easy_escape(*_arg0); end
    def easy_getinfo(*args); end
    def easy_init(*_arg0); end
    def easy_perform(*_arg0); end
    def easy_reset(*_arg0); end
    def easy_setopt(*args); end
    def easy_strerror(*_arg0); end
    def formadd(*args); end
    def formfree(*_arg0); end
    def free(*_arg0); end
    def global_cleanup(*_arg0); end
    def global_init(*_arg0); end
    def init; end
    def multi_add_handle(*_arg0); end
    def multi_cleanup(*_arg0); end
    def multi_fdset(*_arg0); end
    def multi_info_read(*_arg0); end
    def multi_init(*_arg0); end
    def multi_perform(*_arg0); end
    def multi_remove_handle(*_arg0); end
    def multi_setopt(*args); end
    def multi_socket_action(*_arg0); end
    def multi_strerror(*_arg0); end
    def multi_timeout(*_arg0); end
    def select(*_arg0); end
    def slist_append(*_arg0); end
    def slist_free_all(*_arg0); end
    def version(*_arg0); end
    def version_info(*_arg0); end
    def windows?; end
  end
end

Ethon::Curl::DebugInfoType = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::EasyCode = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::EasyOption = T.let(T.unsafe(nil), FFI::Enum)

class Ethon::Curl::FDSet < ::FFI::Struct
  def clear; end
end

Ethon::Curl::FDSet::FD_SETSIZE = T.let(T.unsafe(nil), Integer)
Ethon::Curl::FormOption = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::GLOBAL_ALL = T.let(T.unsafe(nil), Integer)
Ethon::Curl::GLOBAL_DEFAULT = T.let(T.unsafe(nil), Integer)
Ethon::Curl::GLOBAL_SSL = T.let(T.unsafe(nil), Integer)
Ethon::Curl::GLOBAL_WIN32 = T.let(T.unsafe(nil), Integer)
Ethon::Curl::Info = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::InfoType = T.let(T.unsafe(nil), FFI::Enum)
class Ethon::Curl::Msg < ::FFI::Struct; end
Ethon::Curl::MsgCode = T.let(T.unsafe(nil), FFI::Enum)
class Ethon::Curl::MsgData < ::FFI::Union; end
Ethon::Curl::MultiCode = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::MultiOption = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::PollAction = T.let(T.unsafe(nil), FFI::Enum)
Ethon::Curl::SOCKET_BAD = T.let(T.unsafe(nil), Integer)
Ethon::Curl::SOCKET_TIMEOUT = T.let(T.unsafe(nil), Integer)
Ethon::Curl::SocketReadiness = T.let(T.unsafe(nil), FFI::Bitmask)
class Ethon::Curl::Timeval < ::FFI::Struct; end
Ethon::Curl::VERSION_ASYNCHDNS = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_CONV = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_CURLDEBUG = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_DEBUG = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_GSSAPI = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_GSSNEGOTIATE = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_HTTP2 = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_IDN = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_IPV6 = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_KERBEROS4 = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_LARGEFILE = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_LIBZ = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_NOW = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_NTLM = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_NTLM_WB = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_SPNEGO = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_SSL = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_SSPI = T.let(T.unsafe(nil), Integer)
Ethon::Curl::VERSION_TLSAUTH_SRP = T.let(T.unsafe(nil), Integer)
class Ethon::Curl::VersionInfoData < ::FFI::Struct; end
module Ethon::Curls; end

module Ethon::Curls::Codes
  def easy_codes; end
  def multi_codes; end
end

module Ethon::Curls::FormOptions
  def form_options; end
end

module Ethon::Curls::Functions
  class << self
    def extended(base); end
  end
end

module Ethon::Curls::Infos
  def debug_info_types; end
  def get_info_double(option, handle); end
  def get_info_long(option, handle); end
  def get_info_string(option, handle); end
  def info_types; end
  def infos; end
end

module Ethon::Curls::Messages
  def msg_codes; end
end

module Ethon::Curls::Options
  def easy_options(rt); end
  def multi_options(rt); end
  def set_option(option, value, handle, type = T.unsafe(nil)); end

  class << self
    def option(ftype, name, type, num, opts = T.unsafe(nil)); end
    def option_alias(ftype, name, *aliases); end
    def option_type(type); end
  end
end

Ethon::Curls::Options::EASY_OPTIONS = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::FOPTION_STRINGS = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::FUNCS = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::MULTI_OPTIONS = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::OPTION_STRINGS = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::OPTION_TYPE_BASE = T.let(T.unsafe(nil), Hash)
Ethon::Curls::Options::OPTION_TYPE_MAP = T.let(T.unsafe(nil), Hash)

class Ethon::Easy
  include ::Ethon::Easy::Informations
  include ::Ethon::Easy::Callbacks
  include ::Ethon::Easy::Options
  include ::Ethon::Easy::Header
  include ::Ethon::Easy::Http
  include ::Ethon::Easy::Operations
  include ::Ethon::Easy::ResponseCallbacks
  extend ::Ethon::Easy::Features

  def initialize(options = T.unsafe(nil)); end

  def debug_info; end
  def debug_info=(_arg0); end
  def dup; end
  def escape(value); end
  def log_inspect; end
  def mirror; end
  def reset; end
  def response_body; end
  def response_body=(_arg0); end
  def response_headers; end
  def response_headers=(_arg0); end
  def return_code; end
  def return_code=(_arg0); end
  def set_attributes(options); end
  def to_hash; end
end

module Ethon::Easy::Callbacks
  def body_write_callback; end
  def debug_callback; end
  def header_write_callback; end
  def progress_callback; end
  def read_callback; end
  def set_callbacks; end
  def set_progress_callback; end
  def set_read_callback(body); end

  class << self
    def included(base); end
  end
end

class Ethon::Easy::DebugInfo
  def initialize; end

  def add(type, message); end
  def data_in; end
  def data_out; end
  def header_in; end
  def header_out; end
  def messages_for(type); end
  def ssl_data_in; end
  def ssl_data_out; end
  def text; end
  def to_a; end
  def to_h; end
end

Ethon::Easy::DebugInfo::MESSAGE_TYPES = T.let(T.unsafe(nil), Array)

class Ethon::Easy::DebugInfo::Message
  def initialize(type, message); end

  def message; end
  def type; end
end

module Ethon::Easy::Features
  def supports_asynch_dns?; end
  def supports_timeout_ms?; end
  def supports_zlib?; end
end

class Ethon::Easy::Form
  include ::Ethon::Easy::Util
  include ::Ethon::Easy::Queryable

  def initialize(easy, params, multipart = T.unsafe(nil)); end

  def escape; end
  def escape=(_arg0); end
  def first; end
  def last; end
  def materialize; end
  def multipart?; end
  def params_encoding; end
  def params_encoding=(_arg0); end

  private

  def form_add(name, content); end
  def setup_garbage_collection; end
end

module Ethon::Easy::Header
  def compose_header(key, value); end
  def header_list; end
  def headers; end
  def headers=(headers); end
end

module Ethon::Easy::Http
  def http_request(url, action_name, options = T.unsafe(nil)); end

  private

  def fabricate(url, action_name, options); end
end

module Ethon::Easy::Http::Actionable
  def initialize(url, options); end

  def form; end
  def options; end
  def params; end
  def params_encoding; end
  def query_options; end
  def set_form(easy); end
  def set_params(easy); end
  def setup(easy); end
  def url; end

  private

  def parse_options(options); end
end

Ethon::Easy::Http::Actionable::QUERY_OPTIONS = T.let(T.unsafe(nil), Array)

class Ethon::Easy::Http::Custom
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def initialize(verb, url, options); end

  def setup(easy); end
end

class Ethon::Easy::Http::Delete
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

class Ethon::Easy::Http::Get
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

class Ethon::Easy::Http::Head
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

class Ethon::Easy::Http::Options
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

class Ethon::Easy::Http::Patch
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

class Ethon::Easy::Http::Post
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Postable

  def setup(easy); end
end

module Ethon::Easy::Http::Postable
  def set_form(easy); end
end

class Ethon::Easy::Http::Put
  include ::Ethon::Easy::Http::Actionable
  include ::Ethon::Easy::Http::Putable

  def setup(easy); end
end

module Ethon::Easy::Http::Putable
  def set_form(easy); end
end

module Ethon::Easy::Informations
  def appconnect_time; end
  def connect_time; end
  def effective_url; end
  def httpauth_avail; end
  def namelookup_time; end
  def pretransfer_time; end
  def primary_ip; end
  def redirect_count; end
  def redirect_time; end
  def request_size; end
  def response_code; end
  def size_download; end
  def size_upload; end
  def speed_download; end
  def speed_upload; end
  def starttransfer_time; end
  def supports_zlib?; end
  def total_time; end
end

Ethon::Easy::Informations::AVAILABLE_INFORMATIONS = T.let(T.unsafe(nil), Hash)

class Ethon::Easy::Mirror
  def initialize(options = T.unsafe(nil)); end

  def appconnect_time; end
  def connect_time; end
  def debug_info; end
  def effective_url; end
  def httpauth_avail; end
  def log_informations; end
  def namelookup_time; end
  def options; end
  def pretransfer_time; end
  def primary_ip; end
  def redirect_count; end
  def redirect_time; end
  def request_size; end
  def response_body; end
  def response_code; end
  def response_headers; end
  def return_code; end
  def size_download; end
  def size_upload; end
  def speed_download; end
  def speed_upload; end
  def starttransfer_time; end
  def to_hash; end
  def total_time; end

  class << self
    def from_easy(easy); end
  end
end

Ethon::Easy::Mirror::INFORMATIONS_TO_LOG = T.let(T.unsafe(nil), Array)
Ethon::Easy::Mirror::INFORMATIONS_TO_MIRROR = T.let(T.unsafe(nil), Array)

module Ethon::Easy::Operations
  def cleanup; end
  def handle; end
  def handle=(h); end
  def perform; end
  def prepare; end
end

module Ethon::Easy::Options
  def accept_encoding=(value); end
  def accepttimeout_ms=(value); end
  def address_scope=(value); end
  def append=(value); end
  def autoreferer=(value); end
  def buffersize=(value); end
  def cainfo=(value); end
  def capath=(value); end
  def certinfo=(value); end
  def chunk_bgn_function(&block); end
  def chunk_bgn_function=(value); end
  def chunk_data=(value); end
  def chunk_end_function(&block); end
  def chunk_end_function=(value); end
  def closesocketdata=(value); end
  def closesocketfunction(&block); end
  def closesocketfunction=(value); end
  def connect_only=(value); end
  def connecttimeout=(value); end
  def connecttimeout_ms=(value); end
  def conv_from_network_function(&block); end
  def conv_from_network_function=(value); end
  def conv_from_utf8_function(&block); end
  def conv_from_utf8_function=(value); end
  def conv_to_network_function(&block); end
  def conv_to_network_function=(value); end
  def cookie=(value); end
  def cookiefile=(value); end
  def cookiejar=(value); end
  def cookielist=(value); end
  def cookiesession=(value); end
  def copypostfields=(value); end
  def crlf=(value); end
  def crlfile=(value); end
  def customrequest=(value); end
  def debugdata=(value); end
  def debugfunction=(value); end
  def dirlistonly=(value); end
  def dns_cache_timeout=(value); end
  def dns_interface=(value); end
  def dns_local_ip4=(value); end
  def dns_servers=(value); end
  def dns_shuffle_addresses=(value); end
  def dns_use_global_cache=(value); end
  def egdsocket=(value); end
  def encoding=(value); end
  def errorbuffer=(value); end
  def escape=(b); end
  def escape?; end
  def failonerror=(value); end
  def file=(value); end
  def filetime=(value); end
  def fnmatch_data=(value); end
  def fnmatch_function(&block); end
  def fnmatch_function=(value); end
  def followlocation=(value); end
  def forbid_reuse=(value); end
  def fresh_connect=(value); end
  def ftp_account=(value); end
  def ftp_alternative_to_user=(value); end
  def ftp_create_missing_dirs=(value); end
  def ftp_filemethod=(value); end
  def ftp_response_timeout=(value); end
  def ftp_skip_pasv_ip=(value); end
  def ftp_ssl=(value); end
  def ftp_ssl_ccc=(value); end
  def ftp_use_eprt=(value); end
  def ftp_use_epsv=(value); end
  def ftp_use_pret=(value); end
  def ftpappend=(value); end
  def ftplistonly=(value); end
  def ftpport=(value); end
  def ftpsslauth=(value); end
  def gssapi_delegation=(value); end
  def header=(value); end
  def headerdata=(value); end
  def headerfunction(&block); end
  def headerfunction=(value); end
  def http200aliases=(value); end
  def http_content_decoding=(value); end
  def http_transfer_decoding=(value); end
  def http_version=(value); end
  def httpauth=(value); end
  def httpget=(value); end
  def httpheader=(value); end
  def httppost=(value); end
  def httpproxytunnel=(value); end
  def ignore_content_length=(value); end
  def infile=(value); end
  def infilesize=(value); end
  def infilesize_large=(value); end
  def interface=(value); end
  def interleavedata=(value); end
  def interleavefunction(&block); end
  def interleavefunction=(value); end
  def ioctldata=(value); end
  def ioctlfunction(&block); end
  def ioctlfunction=(value); end
  def ipresolve=(value); end
  def issuercert=(value); end
  def keypasswd=(value); end
  def khstat=(value); end
  def krb4level=(value); end
  def krblevel=(value); end
  def localport=(value); end
  def localportrange=(value); end
  def low_speed_limit=(value); end
  def low_speed_time=(value); end
  def mail_auth=(value); end
  def mail_from=(value); end
  def mail_rcpt=(value); end
  def max_recv_speed_large=(value); end
  def max_send_speed_large=(value); end
  def maxconnects=(value); end
  def maxfilesize=(value); end
  def maxfilesize_large=(value); end
  def maxredirs=(value); end
  def multipart=(b); end
  def multipart?; end
  def netrc=(value); end
  def netrc_file=(value); end
  def new_directory_perms=(value); end
  def new_file_perms=(value); end
  def nobody=(value); end
  def noprogress=(value); end
  def noproxy=(value); end
  def nosignal=(value); end
  def opensocketdata=(value); end
  def opensocketfunction(&block); end
  def opensocketfunction=(value); end
  def password=(value); end
  def path_as_is=(value); end
  def pinned_public_key=(value); end
  def pinnedpublickey=(value); end
  def pipewait=(value); end
  def port=(value); end
  def post301=(value); end
  def post=(value); end
  def postfields=(value); end
  def postfieldsize=(value); end
  def postfieldsize_large=(value); end
  def postquote=(value); end
  def postredir=(value); end
  def pre_proxy=(value); end
  def prequote=(value); end
  def private=(value); end
  def progressdata=(value); end
  def progressfunction=(value); end
  def protocols=(value); end
  def proxy=(value); end
  def proxy_cainfo=(value); end
  def proxy_capath=(value); end
  def proxy_crlfile=(value); end
  def proxy_issuercert=(value); end
  def proxy_keypasswd=(value); end
  def proxy_pinned_public_key=(value); end
  def proxy_pinnedpublickey=(value); end
  def proxy_ssl_cipher_list=(value); end
  def proxy_ssl_options=(value); end
  def proxy_ssl_verifyhost=(value); end
  def proxy_ssl_verifypeer=(value); end
  def proxy_sslcert=(value); end
  def proxy_sslcertpasswd=(value); end
  def proxy_sslcerttype=(value); end
  def proxy_sslkey=(value); end
  def proxy_sslkeypasswd=(value); end
  def proxy_sslkeytype=(value); end
  def proxy_sslversion=(value); end
  def proxy_tlsauth_password=(value); end
  def proxy_tlsauth_type=(value); end
  def proxy_tlsauth_username=(value); end
  def proxy_transfer_mode=(value); end
  def proxyauth=(value); end
  def proxypassword=(value); end
  def proxyport=(value); end
  def proxytype=(value); end
  def proxyusername=(value); end
  def proxyuserpwd=(value); end
  def put=(value); end
  def quote=(value); end
  def random_file=(value); end
  def range=(value); end
  def readdata=(value); end
  def readfunction(&block); end
  def readfunction=(value); end
  def redir_protocols=(value); end
  def referer=(value); end
  def resolve=(value); end
  def resume_from=(value); end
  def resume_from_large=(value); end
  def rtsp_client_cseq=(value); end
  def rtsp_request=(value); end
  def rtsp_server_cseq=(value); end
  def rtsp_session_id=(value); end
  def rtsp_stream_uri=(value); end
  def rtsp_transport=(value); end
  def rtspheader=(value); end
  def sasl_ir=(value); end
  def seekdata=(value); end
  def seekfunction(&block); end
  def seekfunction=(value); end
  def server_response_timeout=(value); end
  def share=(value); end
  def sockoptdata=(value); end
  def sockoptfunction(&block); end
  def sockoptfunction=(value); end
  def socks5_gssapi_nec=(value); end
  def socks5_gssapi_service=(value); end
  def ssh_auth_types=(value); end
  def ssh_host_public_key_md5=(value); end
  def ssh_keydata=(value); end
  def ssh_keyfunction(&block); end
  def ssh_keyfunction=(value); end
  def ssh_knownhosts=(value); end
  def ssh_private_keyfile=(value); end
  def ssh_public_keyfile=(value); end
  def ssl_cipher_list=(value); end
  def ssl_ctx_data=(value); end
  def ssl_ctx_function(&block); end
  def ssl_ctx_function=(value); end
  def ssl_options=(value); end
  def ssl_sessionid_cache=(value); end
  def ssl_verifyhost=(value); end
  def ssl_verifypeer=(value); end
  def sslcert=(value); end
  def sslcertpasswd=(value); end
  def sslcerttype=(value); end
  def sslengine=(value); end
  def sslengine_default=(value); end
  def sslkey=(value); end
  def sslkeypasswd=(value); end
  def sslkeytype=(value); end
  def sslversion=(value); end
  def stderr=(value); end
  def tcp_keepalive=(value); end
  def tcp_keepidle=(value); end
  def tcp_keepintvl=(value); end
  def tcp_nodelay=(value); end
  def telnetoptions=(value); end
  def tftp_blksize=(value); end
  def timecondition=(value); end
  def timeout=(value); end
  def timeout_ms=(value); end
  def timevalue=(value); end
  def tlsauth_password=(value); end
  def tlsauth_type=(value); end
  def tlsauth_username=(value); end
  def transfer_encoding=(value); end
  def transfertext=(value); end
  def unix_socket=(value); end
  def unix_socket_path=(value); end
  def unrestricted_auth=(value); end
  def upload=(value); end
  def url; end
  def url=(value); end
  def use_ssl=(value); end
  def useragent=(value); end
  def username=(value); end
  def userpwd=(value); end
  def verbose=(value); end
  def wildcardmatch=(value); end
  def writedata=(value); end
  def writefunction(&block); end
  def writefunction=(value); end
  def writeheader=(value); end
  def xferinfodata=(value); end
  def xferinfofunction=(value); end
end

class Ethon::Easy::Params
  include ::Ethon::Easy::Util
  include ::Ethon::Easy::Queryable

  def initialize(easy, params); end

  def escape; end
  def escape=(_arg0); end
  def params_encoding; end
  def params_encoding=(_arg0); end
end

module Ethon::Easy::Queryable
  def build_query_pairs(hash); end
  def empty?; end
  def file_info(file); end
  def query_pairs; end
  def to_s; end

  private

  def encode_hash_pairs(h, prefix, pairs); end
  def encode_indexed_array_pairs(h, prefix, pairs); end
  def encode_multi_array_pairs(h, prefix, pairs); end
  def encode_rack_array_pairs(h, prefix, pairs); end
  def mime_type(filename); end
  def pairs_for(v, key, pairs); end
  def recursively_generate_pairs(h, prefix, pairs); end

  class << self
    def included(base); end
  end
end

module Ethon::Easy::ResponseCallbacks
  def body(chunk); end
  def complete; end
  def headers; end
  def on_body(&block); end
  def on_complete(&block); end
  def on_headers(&block); end
  def on_progress(&block); end
  def progress(dltotal, dlnow, ultotal, ulnow); end
end

module Ethon::Easy::Util
  extend ::Ethon::Easy::Util

  def escape_zero_byte(value); end
end

module Ethon::Errors; end
class Ethon::Errors::EthonError < ::StandardError; end

class Ethon::Errors::GlobalInit < ::Ethon::Errors::EthonError
  def initialize; end
end

class Ethon::Errors::InvalidOption < ::Ethon::Errors::EthonError
  def initialize(option); end
end

class Ethon::Errors::InvalidValue < ::Ethon::Errors::EthonError
  def initialize(option, value); end
end

class Ethon::Errors::MultiAdd < ::Ethon::Errors::EthonError
  def initialize(code, easy); end
end

class Ethon::Errors::MultiFdset < ::Ethon::Errors::EthonError
  def initialize(code); end
end

class Ethon::Errors::MultiRemove < ::Ethon::Errors::EthonError
  def initialize(code, easy); end
end

class Ethon::Errors::MultiTimeout < ::Ethon::Errors::EthonError
  def initialize(code); end
end

class Ethon::Errors::Select < ::Ethon::Errors::EthonError
  def initialize(errno); end
end

module Ethon::Libc
  extend ::FFI::Library

  def free(*_arg0); end
  def getdtablesize(*_arg0); end

  class << self
    def free(*_arg0); end
    def getdtablesize(*_arg0); end
    def windows?; end
  end
end

module Ethon::Loggable
  def logger; end
  def logger=(logger); end

  private

  def default_logger; end
  def rails_logger; end
end

class Ethon::Multi
  include ::Ethon::Multi::Stack
  include ::Ethon::Multi::Operations
  include ::Ethon::Multi::Options

  def initialize(options = T.unsafe(nil)); end

  def set_attributes(options); end

  private

  def ensure_execution_mode(expected_mode); end
end

module Ethon::Multi::Operations
  def handle; end
  def init_vars; end
  def ongoing?; end
  def perform; end
  def prepare; end
  def socket_action(io = T.unsafe(nil), readiness = T.unsafe(nil)); end

  private

  def check; end
  def get_timeout; end
  def reset_fds; end
  def run; end
  def running_count; end
  def set_fds(timeout); end
  def trigger(running_count_pointer); end
end

Ethon::Multi::Operations::PERFORMED_MULTI = T.let(T.unsafe(nil), String)
Ethon::Multi::Operations::STARTED_MULTI = T.let(T.unsafe(nil), String)

module Ethon::Multi::Options
  def max_total_connections=(value); end
  def maxconnects=(value); end
  def pipelining=(value); end
  def socketdata=(value); end
  def socketfunction=(value); end
  def timerdata=(value); end
  def timerfunction=(value); end

  private

  def value_for(value, type, option = T.unsafe(nil)); end
end

module Ethon::Multi::Stack
  def add(easy); end
  def delete(easy); end
  def easy_handles; end
end

Ethon::VERSION = T.let(T.unsafe(nil), String)
