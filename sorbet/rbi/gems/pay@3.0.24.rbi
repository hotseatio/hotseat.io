# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pay` gem.
# Please instead update this file by running `bin/tapioca gem pay`.

module Pay
  def application_name; end
  def application_name=(val); end
  def automount_routes; end
  def automount_routes=(val); end
  def braintree_gateway; end
  def braintree_gateway=(val); end
  def business_address; end
  def business_address=(val); end
  def business_logo; end
  def business_logo=(val); end
  def business_name; end
  def business_name=(val); end
  def default_plan_name; end
  def default_plan_name=(val); end
  def default_product_name; end
  def default_product_name=(val); end
  def model_parent_class; end
  def model_parent_class=(val); end
  def routes_path; end
  def routes_path=(val); end
  def send_emails; end
  def send_emails=(val); end
  def support_email; end
  def support_email=(val); end

  class << self
    def application_name; end
    def application_name=(val); end
    def automount_routes; end
    def automount_routes=(val); end
    def braintree_gateway; end
    def braintree_gateway=(val); end
    def business_address; end
    def business_address=(val); end
    def business_logo; end
    def business_logo=(val); end
    def business_name; end
    def business_name=(val); end
    def default_plan_name; end
    def default_plan_name=(val); end
    def default_product_name; end
    def default_product_name=(val); end
    def model_parent_class; end
    def model_parent_class=(val); end
    def routes_path; end
    def routes_path=(val); end
    def send_emails; end
    def send_emails=(val); end
    def setup; end
    def support_email; end
    def support_email=(val); end
  end
end

class Pay::ActionRequired < ::Pay::PaymentError
  def message; end
end

module Pay::Adapter
  extend ::ActiveSupport::Concern

  class << self
    def current_adapter; end
    def json_column_type; end
  end
end

class Pay::ApplicationController < ::ActionController::Base
  private

  def _layout(lookup_context, formats); end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end

module Pay::ApplicationHelper; end
class Pay::ApplicationJob < ::ActiveJob::Base; end

class Pay::ApplicationMailer < ::ActionMailer::Base
  private

  def _layout(lookup_context, formats); end

  class << self
    def _layout; end
    def _layout_conditions; end
    def default_params; end
  end
end

class Pay::ApplicationRecord < ::ApplicationRecord
  include ::Pay::ApplicationRecord::GeneratedAttributeMethods
  include ::Pay::ApplicationRecord::GeneratedAssociationMethods

  class << self
    def _validators; end
    def defined_enums; end
    def table_name_prefix; end
  end
end

module Pay::ApplicationRecord::GeneratedAssociationMethods; end
module Pay::ApplicationRecord::GeneratedAttributeMethods; end

module Pay::Attributes
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Pay::Attributes::ClassMethods
end

module Pay::Attributes::ClassMethods
  def pay_customer; end
  def pay_merchant; end
end

module Pay::Attributes::CustomerExtension
  extend ::ActiveSupport::Concern

  def cancel_active_pay_subscriptions!; end
  def set_payment_processor(processor_name, allow_fake: T.unsafe(nil), **attributes); end
end

module Pay::Attributes::MerchantExtension
  extend ::ActiveSupport::Concern

  def set_merchant_processor(processor_name, **attributes); end
end

module Pay::Billable; end

module Pay::Billable::SyncCustomer
  extend ::ActiveSupport::Concern

  def pay_should_sync_customer?; end

  private

  def enqeue_sync_email_job; end
end

module Pay::Braintree
  extend ::Pay::Env

  class << self
    def configure_webhooks; end
    def environment; end
    def merchant_id; end
    def private_key; end
    def public_key; end
    def setup; end
  end
end

class Pay::Braintree::AuthorizationError < ::Pay::Braintree::Error
  def message; end
end

class Pay::Braintree::Billable
  def initialize(pay_customer); end

  def add_payment_method(token, default: T.unsafe(nil)); end
  def card_details_for_braintree_transaction(transaction); end
  def charge(amount, options = T.unsafe(nil)); end
  def customer; end
  def customer_name(*_arg0, &_arg1); end
  def email(*_arg0, &_arg1); end
  def gateway; end
  def pay_customer; end
  def payment_method_token(*_arg0, &_arg1); end
  def payment_method_token?(*_arg0, &_arg1); end
  def processor_id(*_arg0, &_arg1); end
  def processor_id?(*_arg0, &_arg1); end
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end
  def save_payment_method(payment_method, default:); end
  def save_transaction(transaction); end
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end
  def trial_end_date(subscription); end
  def update_customer!; end
  def update_email!; end
end

class Pay::Braintree::Charge
  def initialize(pay_charge); end

  def charge; end
  def pay_charge; end
  def processor_id(*_arg0, &_arg1); end
  def refund!(amount_to_refund); end
end

class Pay::Braintree::Error < ::Pay::Error
  def initialize(result); end

  def cause; end
  def result; end
end

class Pay::Braintree::PaymentMethod
  def initialize(pay_payment_method); end

  def customer(*_arg0, &_arg1); end
  def detach; end
  def make_default!; end
  def pay_payment_method; end
  def processor_id(*_arg0, &_arg1); end

  private

  def gateway; end

  class << self
    def sync(id, object: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

class Pay::Braintree::Subscription
  def initialize(pay_subscription); end

  def active?(*_arg0, &_arg1); end
  def cancel; end
  def cancel_now!; end
  def canceled?(*_arg0, &_arg1); end
  def customer(*_arg0, &_arg1); end
  def ends_at(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def on_grace_period?; end
  def on_trial?(*_arg0, &_arg1); end
  def pause; end
  def paused?; end
  def pay_subscription; end
  def processor_id(*_arg0, &_arg1); end
  def processor_plan(*_arg0, &_arg1); end
  def processor_subscription(*_arg0, &_arg1); end
  def prorate(*_arg0, &_arg1); end
  def prorate?(*_arg0, &_arg1); end
  def quantity(*_arg0, &_arg1); end
  def quantity?(*_arg0, &_arg1); end
  def resume; end
  def subscription(**options); end
  def swap(plan); end
  def trial_ends_at(*_arg0, &_arg1); end

  private

  def discount_for_switching_to_monthly(current_plan, plan); end
  def discount_for_switching_to_yearly; end
  def find_braintree_plan(id); end
  def gateway; end
  def money_remaining_on_yearly_plan(current_plan); end
  def swap_across_frequencies(plan); end
  def switching_to_monthly_plan?(current_plan, plan); end
  def would_change_billing_frequency?(plan); end
end

module Pay::Braintree::Webhooks; end

class Pay::Braintree::Webhooks::SubscriptionCanceled
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionChargedSuccessfully
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionChargedUnsuccessfully
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionExpired
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionTrialEnded
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionWentActive
  def call(event); end
end

class Pay::Braintree::Webhooks::SubscriptionWentPastDue
  def call(event); end
end

class Pay::Charge < ::Pay::ApplicationRecord
  include ::Pay::Charge::GeneratedAttributeMethods
  include ::Pay::Charge::GeneratedAssociationMethods

  def amount_refunded_with_currency; end
  def amount_with_currency; end
  def autosave_associated_records_for_customer(*args); end
  def autosave_associated_records_for_subscription(*args); end
  def braintree?; end
  def charged_to; end
  def fake_processor?; end
  def full_refund?; end
  def paddle?; end
  def partial_refund?; end
  def payment_processor; end
  def processor_charge; end
  def refund!(refund_amount = T.unsafe(nil)); end
  def refunded?; end
  def stripe?; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def braintree(*args); end
    def defined_enums; end
    def fake_processor(*args); end
    def find_by_processor_and_id(processor, processor_id); end
    def paddle(*args); end
    def pay_processor_for(name); end
    def sorted(*args); end
    def stripe(*args); end
    def with_active_customer(*args); end
    def with_deleted_customer(*args); end
  end
end

module Pay::Charge::GeneratedAssociationMethods
  def build_customer(*args, &block); end
  def build_subscription(*args, &block); end
  def create_customer(*args, &block); end
  def create_customer!(*args, &block); end
  def create_subscription(*args, &block); end
  def create_subscription!(*args, &block); end
  def customer; end
  def customer=(value); end
  def reload_customer; end
  def reload_subscription; end
  def subscription; end
  def subscription=(value); end
end

module Pay::Charge::GeneratedAttributeMethods; end

class Pay::Currency
  include ::ActionView::Helpers::NumberHelper

  def initialize(iso_code); end

  def attributes; end
  def delimiter; end
  def format; end
  def format_amount(amount, **options); end
  def precision; end
  def separator; end
  def subunit; end
  def subunit?; end
  def subunit_to_unit; end
  def unit; end

  class << self
    def all; end
    def format(amount, currency:, **options); end
  end
end

class Pay::Customer < ::Pay::ApplicationRecord
  include ::Pay::Customer::GeneratedAttributeMethods
  include ::Pay::Customer::GeneratedAssociationMethods

  def active?; end
  def autosave_associated_records_for_charges(*args); end
  def autosave_associated_records_for_default_payment_method; end
  def autosave_associated_records_for_owner(*args); end
  def autosave_associated_records_for_payment_methods(*args); end
  def autosave_associated_records_for_subscriptions(*args); end
  def braintree?; end
  def customer_name; end
  def deleted?; end
  def email(*_arg0, &_arg1); end
  def fake_processor?; end
  def has_incomplete_payment?; end
  def method_missing(method, *args, &block); end
  def on_generic_trial?; end
  def on_trial?(name: T.unsafe(nil), plan: T.unsafe(nil)); end
  def on_trial_or_subscribed?(name: T.unsafe(nil), processor_plan: T.unsafe(nil)); end
  def paddle?; end
  def pay_processor; end
  def stripe?; end
  def subscribed?(name: T.unsafe(nil), processor_plan: T.unsafe(nil)); end
  def subscription(name: T.unsafe(nil)); end
  def update_payment_method(payment_method_id); end
  def validate_associated_records_for_charges(*args); end
  def validate_associated_records_for_payment_methods(*args); end
  def validate_associated_records_for_subscriptions(*args); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def active(*args); end
    def after_add_for_charges; end
    def after_add_for_charges=(value); end
    def after_add_for_payment_methods; end
    def after_add_for_payment_methods=(value); end
    def after_add_for_subscriptions; end
    def after_add_for_subscriptions=(value); end
    def after_remove_for_charges; end
    def after_remove_for_charges=(value); end
    def after_remove_for_payment_methods; end
    def after_remove_for_payment_methods=(value); end
    def after_remove_for_subscriptions; end
    def after_remove_for_subscriptions=(value); end
    def attributes_to_define_after_schema_loads; end
    def before_add_for_charges; end
    def before_add_for_charges=(value); end
    def before_add_for_payment_methods; end
    def before_add_for_payment_methods=(value); end
    def before_add_for_subscriptions; end
    def before_add_for_subscriptions=(value); end
    def before_remove_for_charges; end
    def before_remove_for_charges=(value); end
    def before_remove_for_payment_methods; end
    def before_remove_for_payment_methods=(value); end
    def before_remove_for_subscriptions; end
    def before_remove_for_subscriptions=(value); end
    def braintree(*args); end
    def defined_enums; end
    def deleted(*args); end
    def fake_processor(*args); end
    def paddle(*args); end
    def pay_processor_for(name); end
    def stripe(*args); end
  end
end

module Pay::Customer::GeneratedAssociationMethods
  def build_default_payment_method(*args, &block); end
  def charge_ids; end
  def charge_ids=(ids); end
  def charges; end
  def charges=(value); end
  def create_default_payment_method(*args, &block); end
  def create_default_payment_method!(*args, &block); end
  def default_payment_method; end
  def default_payment_method=(value); end
  def owner; end
  def owner=(value); end
  def payment_method_ids; end
  def payment_method_ids=(ids); end
  def payment_methods; end
  def payment_methods=(value); end
  def reload_default_payment_method; end
  def reload_owner; end
  def subscription_ids; end
  def subscription_ids=(ids); end
  def subscriptions; end
  def subscriptions=(value); end
end

module Pay::Customer::GeneratedAttributeMethods; end

class Pay::CustomerSyncJob < ::Pay::ApplicationJob
  def perform(pay_customer_id); end

  class << self
    def queue_name; end
  end
end

class Pay::Engine < ::Rails::Engine; end

module Pay::Env
  private

  def credentials; end
  def env; end
  def find_value_by_name(scope, name); end
  def secrets; end
end

class Pay::Error < ::StandardError; end
module Pay::FakeProcessor; end

class Pay::FakeProcessor::Billable
  def initialize(pay_customer); end

  def add_payment_method(payment_method_id, default: T.unsafe(nil)); end
  def card_token(*_arg0, &_arg1); end
  def charge(amount, options = T.unsafe(nil)); end
  def customer; end
  def customer_name(*_arg0, &_arg1); end
  def email(*_arg0, &_arg1); end
  def pay_customer; end
  def processor_id(*_arg0, &_arg1); end
  def processor_id?(*_arg0, &_arg1); end
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end
  def trial_end_date(subscription); end
  def update_customer!; end
  def update_email!; end
end

class Pay::FakeProcessor::Charge
  def initialize(pay_charge); end

  def charge; end
  def owner(*_arg0, &_arg1); end
  def pay_charge; end
  def processor_id(*_arg0, &_arg1); end
  def refund!(amount_to_refund); end
end

class Pay::FakeProcessor::Error < ::Pay::Error; end

class Pay::FakeProcessor::PaymentMethod
  def initialize(pay_payment_method); end

  def customer(*_arg0, &_arg1); end
  def detach; end
  def make_default!; end
  def pay_payment_method; end
  def processor_id(*_arg0, &_arg1); end
end

class Pay::FakeProcessor::Subscription
  def initialize(pay_subscription); end

  def cancel; end
  def cancel_now!; end
  def canceled?(*_arg0, &_arg1); end
  def change_quantity(quantity); end
  def ends_at(*_arg0, &_arg1); end
  def on_grace_period?; end
  def on_trial?(*_arg0, &_arg1); end
  def owner(*_arg0, &_arg1); end
  def pause; end
  def paused?; end
  def pay_subscription; end
  def processor_id(*_arg0, &_arg1); end
  def processor_plan(*_arg0, &_arg1); end
  def processor_subscription(*_arg0, &_arg1); end
  def prorate(*_arg0, &_arg1); end
  def quantity(*_arg0, &_arg1); end
  def quantity?(*_arg0, &_arg1); end
  def resume; end
  def subscription(**options); end
  def swap(plan); end
end

class Pay::InvalidPaymentMethod < ::Pay::PaymentError
  def message; end
end

class Pay::Merchant < ::Pay::ApplicationRecord
  include ::Pay::Merchant::GeneratedAttributeMethods
  include ::Pay::Merchant::GeneratedAssociationMethods

  def autosave_associated_records_for_owner(*args); end
  def method_missing(method, *args, &block); end
  def pay_processor; end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def defined_enums; end
    def pay_processor_for(name); end
  end
end

module Pay::Merchant::GeneratedAssociationMethods
  def owner; end
  def owner=(value); end
  def reload_owner; end
end

module Pay::Merchant::GeneratedAttributeMethods; end

module Pay::NanoId
  class << self
    def generate(size: T.unsafe(nil)); end
  end
end

Pay::NanoId::ALPHABET = T.let(T.unsafe(nil), String)
Pay::NanoId::ALPHABET_SIZE = T.let(T.unsafe(nil), Integer)

module Pay::Paddle
  extend ::Pay::Env

  class << self
    def configure_webhooks; end
    def environment; end
    def owner_from_passthrough(passthrough); end
    def parse_passthrough(passthrough); end
    def passthrough(owner:, **options); end
    def public_key_base64; end
    def setup; end
    def vendor_auth_code; end
    def vendor_id; end
  end
end

class Pay::Paddle::Billable
  def initialize(pay_customer); end

  def add_payment_method(token, default: T.unsafe(nil)); end
  def card_token(*_arg0, &_arg1); end
  def charge(amount, options = T.unsafe(nil)); end
  def customer; end
  def customer_name(*_arg0, &_arg1); end
  def email(*_arg0, &_arg1); end
  def pay_customer; end
  def processor_id(*_arg0, &_arg1); end
  def processor_id?(*_arg0, &_arg1); end
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end
  def trial_end_date(subscription); end
  def update_customer!; end
  def update_email!; end
end

class Pay::Paddle::Charge
  def initialize(pay_charge); end

  def charge; end
  def customer(*_arg0, &_arg1); end
  def pay_charge; end
  def processor_id(*_arg0, &_arg1); end
  def refund!(amount_to_refund); end
end

class Pay::Paddle::Error < ::Pay::Error
  def message(*_arg0, &_arg1); end
end

class Pay::Paddle::PaymentMethod
  def initialize(pay_payment_method); end

  def customer(*_arg0, &_arg1); end
  def detach; end
  def make_default!; end
  def pay_payment_method; end
  def processor_id(*_arg0, &_arg1); end

  class << self
    def payment_method_details_for(subscription_id:); end
    def sync(pay_customer:, attributes: T.unsafe(nil)); end
  end
end

class Pay::Paddle::Subscription
  def initialize(pay_subscription); end

  def active?(*_arg0, &_arg1); end
  def cancel; end
  def cancel_now!; end
  def canceled?(*_arg0, &_arg1); end
  def ends_at(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def on_grace_period?; end
  def on_trial?(*_arg0, &_arg1); end
  def owner(*_arg0, &_arg1); end
  def paddle_paused_from(*_arg0, &_arg1); end
  def pause; end
  def paused?; end
  def pay_subscription; end
  def processor_id(*_arg0, &_arg1); end
  def processor_plan(*_arg0, &_arg1); end
  def processor_subscription(*_arg0, &_arg1); end
  def prorate(*_arg0, &_arg1); end
  def prorate?(*_arg0, &_arg1); end
  def quantity(*_arg0, &_arg1); end
  def quantity?(*_arg0, &_arg1); end
  def resume; end
  def subscription(**options); end
  def swap(plan); end
  def trial_ends_at(*_arg0, &_arg1); end

  class << self
    def sync(subscription_id, object: T.unsafe(nil), name: T.unsafe(nil)); end
  end
end

module Pay::Paddle::Webhooks; end

class Pay::Paddle::Webhooks::SignatureVerifier
  def initialize(data); end

  def verify; end

  private

  def serialize(var, assoc = T.unsafe(nil)); end
end

class Pay::Paddle::Webhooks::SubscriptionCancelled
  def call(event); end
end

class Pay::Paddle::Webhooks::SubscriptionCreated
  def call(event); end
end

class Pay::Paddle::Webhooks::SubscriptionPaymentRefunded
  def call(event); end
end

class Pay::Paddle::Webhooks::SubscriptionPaymentSucceeded
  def call(event); end
  def create_charge(pay_customer, event); end
  def notify_user(pay_charge); end
end

class Pay::Paddle::Webhooks::SubscriptionUpdated
  def call(event); end
end

class Pay::Payment
  def initialize(intent); end

  def amount(*_arg0, &_arg1); end
  def amount_with_currency; end
  def canceled?; end
  def cancelled?; end
  def client_secret(*_arg0, &_arg1); end
  def confirm(*_arg0, &_arg1); end
  def currency(*_arg0, &_arg1); end
  def customer(*_arg0, &_arg1); end
  def id(*_arg0, &_arg1); end
  def intent; end
  def payment_intent?; end
  def requires_action?; end
  def requires_payment_method?; end
  def setup_intent?; end
  def status(*_arg0, &_arg1); end
  def succeeded?; end
  def validate; end

  class << self
    def from_id(id); end
  end
end

class Pay::PaymentError < ::StandardError
  def initialize(payment); end

  def payment; end
end

class Pay::PaymentMethod < ::Pay::ApplicationRecord
  include ::Pay::PaymentMethod::GeneratedAttributeMethods
  include ::Pay::PaymentMethod::GeneratedAssociationMethods

  def autosave_associated_records_for_customer(*args); end
  def clear_payment_method_type_change(*args); end
  def make_default!; end
  def payment_method_type(*args); end
  def payment_method_type=(*args); end
  def payment_method_type?(*args); end
  def payment_method_type_before_last_save(*args); end
  def payment_method_type_before_type_cast(*args); end
  def payment_method_type_came_from_user?(*args); end
  def payment_method_type_change(*args); end
  def payment_method_type_change_to_be_saved(*args); end
  def payment_method_type_changed?(*args); end
  def payment_method_type_for_database(*args); end
  def payment_method_type_in_database(*args); end
  def payment_method_type_previous_change(*args); end
  def payment_method_type_previously_changed?(*args); end
  def payment_method_type_previously_was(*args); end
  def payment_method_type_was(*args); end
  def payment_method_type_will_change!(*args); end
  def payment_processor; end
  def restore_payment_method_type!(*args); end
  def saved_change_to_payment_method_type(*args); end
  def saved_change_to_payment_method_type?(*args); end
  def will_save_change_to_payment_method_type?(*args); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def attribute_aliases; end
    def defined_enums; end
    def find_by_processor_and_id(processor, processor_id); end
    def pay_processor_for(name); end
  end
end

module Pay::PaymentMethod::GeneratedAssociationMethods
  def build_customer(*args, &block); end
  def create_customer(*args, &block); end
  def create_customer!(*args, &block); end
  def customer; end
  def customer=(value); end
  def reload_customer; end
end

module Pay::PaymentMethod::GeneratedAttributeMethods; end

class Pay::PaymentsController < ::Pay::ApplicationController
  def show; end

  private

  def _layout(lookup_context, formats); end

  class << self
    def _layout; end
    def _layout_conditions; end
    def middleware_stack; end
  end
end

module Pay::Receipts
  def filename; end
  def invoice; end
  def invoice_filename; end
  def invoice_pdf(**options); end
  def line_items; end
  def product; end
  def receipt; end
  def receipt_filename; end
  def receipt_pdf(**options); end
end

module Pay::Stripe
  extend ::Pay::Env

  class << self
    def configure_webhooks; end
    def private_key; end
    def public_key; end
    def setup; end
    def signing_secret; end
  end
end

class Pay::Stripe::Billable
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::Routing::UrlFor

  def initialize(pay_customer); end

  def add_payment_method(payment_method_id, default: T.unsafe(nil)); end
  def billing_portal(**options); end
  def charge(amount, options = T.unsafe(nil)); end
  def checkout(**options); end
  def checkout_charge(amount:, name:, quantity: T.unsafe(nil), **options); end
  def create_setup_intent; end
  def customer; end
  def customer_name(*_arg0, &_arg1); end
  def default_url_options; end
  def default_url_options=(_arg0); end
  def default_url_options?; end
  def email(*_arg0, &_arg1); end
  def invoice!(options = T.unsafe(nil)); end
  def pay_customer; end
  def payment_method_token(*_arg0, &_arg1); end
  def payment_method_token?(*_arg0, &_arg1); end
  def processor_id(*_arg0, &_arg1); end
  def processor_id?(*_arg0, &_arg1); end
  def processor_subscription(subscription_id, options = T.unsafe(nil)); end
  def save_payment_method(payment_method, default:); end
  def stripe_account(*_arg0, &_arg1); end
  def subscribe(name: T.unsafe(nil), plan: T.unsafe(nil), **options); end
  def sync_subscriptions; end
  def trial_end_date(stripe_sub); end
  def upcoming_invoice; end
  def update_customer!; end
  def update_email!; end

  private

  def merge_session_id_param(url); end
  def stripe_options; end

  class << self
    def _routes; end
    def default_url_options; end
    def default_url_options=(value); end
    def default_url_options?; end
  end
end

class Pay::Stripe::Charge
  def initialize(pay_charge); end

  def charge; end
  def pay_charge; end
  def processor_id(*_arg0, &_arg1); end
  def refund!(amount_to_refund, **options); end
  def stripe_account(*_arg0, &_arg1); end

  private

  def stripe_options; end

  class << self
    def sync(charge_id, object: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

class Pay::Stripe::Error < ::Pay::Error
  def message(*_arg0, &_arg1); end
end

class Pay::Stripe::Merchant
  def initialize(pay_merchant); end

  def account; end
  def account_link(refresh_url:, return_url:, type: T.unsafe(nil), **options); end
  def create_account(**options); end
  def login_link(**options); end
  def pay_merchant; end
  def processor_id(*_arg0, &_arg1); end
  def transfer(amount:, currency: T.unsafe(nil), **options); end
end

class Pay::Stripe::PaymentMethod
  def initialize(pay_payment_method); end

  def customer(*_arg0, &_arg1); end
  def detach; end
  def make_default!; end
  def pay_payment_method; end
  def processor_id(*_arg0, &_arg1); end

  private

  def stripe_options; end

  class << self
    def extract_attributes(payment_method); end
    def sync(id, object: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

class Pay::Stripe::Subscription
  def initialize(pay_subscription); end

  def active?(*_arg0, &_arg1); end
  def cancel; end
  def cancel_now!; end
  def canceled?(*_arg0, &_arg1); end
  def change_quantity(quantity); end
  def ends_at(*_arg0, &_arg1); end
  def name(*_arg0, &_arg1); end
  def on_grace_period?; end
  def on_trial?(*_arg0, &_arg1); end
  def pause; end
  def paused?; end
  def pay_subscription; end
  def processor_id(*_arg0, &_arg1); end
  def processor_plan(*_arg0, &_arg1); end
  def processor_subscription(*_arg0, &_arg1); end
  def prorate(*_arg0, &_arg1); end
  def prorate?(*_arg0, &_arg1); end
  def quantity(*_arg0, &_arg1); end
  def quantity?(*_arg0, &_arg1); end
  def resume; end
  def stripe_account(*_arg0, &_arg1); end
  def subscription(**options); end
  def swap(plan); end
  def trial_ends_at(*_arg0, &_arg1); end

  private

  def stripe_options; end

  class << self
    def sync(subscription_id, object: T.unsafe(nil), name: T.unsafe(nil), stripe_account: T.unsafe(nil), try: T.unsafe(nil), retries: T.unsafe(nil)); end
  end
end

module Pay::Stripe::Webhooks; end

class Pay::Stripe::Webhooks::AccountUpdated
  def call(event); end
end

class Pay::Stripe::Webhooks::ChargeRefunded
  def call(event); end
end

class Pay::Stripe::Webhooks::ChargeSucceeded
  def call(event); end
end

class Pay::Stripe::Webhooks::CheckoutSessionAsyncPaymentSucceeded
  def call(event); end
end

class Pay::Stripe::Webhooks::CheckoutSessionCompleted
  def call(event); end
end

class Pay::Stripe::Webhooks::CustomerDeleted
  def call(event); end
end

class Pay::Stripe::Webhooks::CustomerUpdated
  def call(event); end
end

class Pay::Stripe::Webhooks::PaymentActionRequired
  def call(event); end
end

class Pay::Stripe::Webhooks::PaymentIntentSucceeded
  def call(event); end
end

class Pay::Stripe::Webhooks::PaymentMethodAttached
  def call(event); end
end

class Pay::Stripe::Webhooks::PaymentMethodDetached
  def call(event); end
end

class Pay::Stripe::Webhooks::PaymentMethodUpdated
  def call(event); end
end

class Pay::Stripe::Webhooks::SubscriptionCreated
  def call(event); end
end

class Pay::Stripe::Webhooks::SubscriptionDeleted
  def call(event); end
end

class Pay::Stripe::Webhooks::SubscriptionRenewing
  def call(event); end
end

class Pay::Stripe::Webhooks::SubscriptionUpdated
  def call(event); end
end

class Pay::Subscription < ::Pay::ApplicationRecord
  include ::Pay::Subscription::GeneratedAttributeMethods
  include ::Pay::Subscription::GeneratedAssociationMethods

  def active?; end
  def autosave_associated_records_for_charges(*args); end
  def autosave_associated_records_for_customer(*args); end
  def braintree?; end
  def cancel(*_arg0, &_arg1); end
  def cancel_now!(*_arg0, &_arg1); end
  def canceled?; end
  def cancelled?; end
  def change_quantity(quantity); end
  def fake_processor?; end
  def generic_trial?; end
  def has_incomplete_payment?; end
  def incomplete?; end
  def latest_payment; end
  def no_prorate; end
  def on_grace_period?(*_arg0, &_arg1); end
  def on_trial?; end
  def paddle?; end
  def paddle_paused_from; end
  def past_due?; end
  def pause(*_arg0, &_arg1); end
  def paused?(*_arg0, &_arg1); end
  def payment_processor; end
  def processor_subscription(**options); end
  def resume; end
  def skip_trial; end
  def stripe?; end
  def swap(plan); end
  def swap_and_invoice(plan); end
  def validate_associated_records_for_charges(*args); end

  private

  def cancel_if_active; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def active(*args); end
    def after_add_for_charges; end
    def after_add_for_charges=(value); end
    def after_remove_for_charges; end
    def after_remove_for_charges=(value); end
    def attributes_to_define_after_schema_loads; end
    def before_add_for_charges; end
    def before_add_for_charges=(value); end
    def before_remove_for_charges; end
    def before_remove_for_charges=(value); end
    def braintree(*args); end
    def cancelled(*args); end
    def defined_enums; end
    def fake_processor(*args); end
    def find_by_processor_and_id(processor, processor_id); end
    def for_name(*args); end
    def incomplete(*args); end
    def on_grace_period(*args); end
    def on_trial(*args); end
    def paddle(*args); end
    def past_due(*args); end
    def pay_processor_for(name); end
    def stripe(*args); end
    def with_active_customer(*args); end
    def with_deleted_customer(*args); end
  end
end

module Pay::Subscription::GeneratedAssociationMethods
  def build_customer(*args, &block); end
  def charge_ids; end
  def charge_ids=(ids); end
  def charges; end
  def charges=(value); end
  def create_customer(*args, &block); end
  def create_customer!(*args, &block); end
  def customer; end
  def customer=(value); end
  def reload_customer; end
end

module Pay::Subscription::GeneratedAttributeMethods; end
Pay::Subscription::STATUSES = T.let(T.unsafe(nil), Array)

class Pay::UserMailer < ::Pay::ApplicationMailer
  def payment_action_required; end
  def receipt; end
  def refund; end
  def subscription_renewing; end

  private

  def _layout(lookup_context, formats); end
  def to; end
end

Pay::VERSION = T.let(T.unsafe(nil), String)

class Pay::Webhook < ::Pay::ApplicationRecord
  include ::Pay::Webhook::GeneratedAttributeMethods
  include ::Pay::Webhook::GeneratedAssociationMethods

  def process!; end
  def rehydrated_event; end
  def to_recursive_ostruct(hash); end

  class << self
    def __callbacks; end
    def _validators; end
    def defined_enums; end
  end
end

module Pay::Webhook::GeneratedAssociationMethods; end
module Pay::Webhook::GeneratedAttributeMethods; end

module Pay::Webhooks
  class << self
    def configure(*_arg0, &_arg1); end
    def delegator; end
    def instrument(*_arg0, &_arg1); end
  end
end

class Pay::Webhooks::BraintreeController < ::Pay::ApplicationController
  def create; end

  private

  def _layout(lookup_context, formats); end
  def queue_event(event); end
  def verified_event; end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end

class Pay::Webhooks::Delegator
  def initialize; end

  def all(callable = T.unsafe(nil), &block); end
  def backend; end
  def configure(&block); end
  def instrument(event:, type:); end
  def listening?(type); end
  def subscribe(name, callable = T.unsafe(nil), &block); end
  def unsubscribe(name); end

  private

  def name_with_namespace(name, delimiter: T.unsafe(nil)); end
  def to_regexp(name); end
end

class Pay::Webhooks::Delegator::NotificationAdapter
  def initialize(subscriber); end

  def call(*args); end
end

class Pay::Webhooks::PaddleController < ::Pay::ApplicationController
  def create; end

  private

  def _layout(lookup_context, formats); end
  def queue_event(event); end
  def verified_event; end
  def verify_params; end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end

class Pay::Webhooks::ProcessJob < ::Pay::ApplicationJob
  def perform(pay_webhook); end
end

class Pay::Webhooks::StripeController < ::Pay::ApplicationController
  def create; end

  private

  def _layout(lookup_context, formats); end
  def log_error(e); end
  def queue_event(event); end
  def secrets(payload, signature); end
  def verified_event; end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end
