# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-attack` gem.
# Please instead update this file by running `bin/tapioca gem rack-attack`.

# Rack::Attack::Request is the same as ::Rack::Request by default.
#
# This is a safe place to add custom helper methods to the request object
# through monkey patching:
#
#   class Rack::Attack::Request < ::Rack::Request
#     def localhost?
#       ip == "127.0.0.1"
#     end
#   end
#
#   Rack::Attack.safelist("localhost") {|req| req.localhost? }
module Rack
  class << self
    # Return the Rack release as a dotted string.
    def release; end

    # Return the Rack protocol version as a dotted string.
    def version; end
  end
end

class Rack::Attack
  # @return [Attack] a new instance of Attack
  def initialize(app); end

  def call(env); end

  # Returns the value of attribute configuration.
  def configuration; end

  class << self
    def blocklist(*args, &block); end
    def blocklist_ip(*args, &block); end
    def blocklisted_responder(*args, &block); end
    def blocklisted_responder=(*args, &block); end
    def blocklisted_response(*args, &block); end
    def blocklisted_response=(*args, &block); end
    def blocklists(*args, &block); end
    def cache; end
    def clear!; end
    def clear_configuration(*args, &block); end

    # Returns the value of attribute configuration.
    def configuration; end

    # Returns the value of attribute enabled.
    def enabled; end

    # Sets the attribute enabled
    #
    # @param value the value to set the attribute enabled to.
    def enabled=(_arg0); end

    def instrument(request); end

    # Returns the value of attribute notifier.
    def notifier; end

    # Sets the attribute notifier
    #
    # @param value the value to set the attribute notifier to.
    def notifier=(_arg0); end

    def reset!; end
    def safelist(*args, &block); end
    def safelist_ip(*args, &block); end
    def safelists(*args, &block); end
    def throttle(*args, &block); end

    # Returns the value of attribute throttle_discriminator_normalizer.
    def throttle_discriminator_normalizer; end

    # Sets the attribute throttle_discriminator_normalizer
    #
    # @param value the value to set the attribute throttle_discriminator_normalizer to.
    def throttle_discriminator_normalizer=(_arg0); end

    def throttled_responder(*args, &block); end
    def throttled_responder=(*args, &block); end
    def throttled_response(*args, &block); end
    def throttled_response=(*args, &block); end
    def throttled_response_retry_after_header(*args, &block); end
    def throttled_response_retry_after_header=(*args, &block); end
    def throttles(*args, &block); end
    def track(*args, &block); end
    def tracks(*args, &block); end
  end
end

class Rack::Attack::Allow2Ban < ::Rack::Attack::Fail2Ban
  class << self
    protected

    # everything is the same here except we only return true
    # (blocking the request) if they have tripped the limit.
    def fail!(discriminator, bantime, findtime, maxretry); end

    def key_prefix; end
  end
end

class Rack::Attack::BaseProxy < ::SimpleDelegator
  class << self
    # @raise [NotImplementedError]
    # @return [Boolean]
    def handle?(_store); end

    # @private
    def inherited(klass); end

    def lookup(store); end
    def proxies; end
  end
end

class Rack::Attack::Blocklist < ::Rack::Attack::Check
  # @return [Blocklist] a new instance of Blocklist
  def initialize(name = T.unsafe(nil), &block); end
end

class Rack::Attack::Cache
  # @return [Cache] a new instance of Cache
  def initialize; end

  def count(unprefixed_key, period); end
  def delete(unprefixed_key); end

  # Returns the value of attribute last_epoch_time.
  def last_epoch_time; end

  # Returns the value of attribute prefix.
  def prefix; end

  # Sets the attribute prefix
  #
  # @param value the value to set the attribute prefix to.
  def prefix=(_arg0); end

  def read(unprefixed_key); end
  def reset!; end
  def reset_count(unprefixed_key, period); end

  # Returns the value of attribute store.
  def store; end

  def store=(store); end
  def write(unprefixed_key, value, expires_in); end

  private

  def do_count(key, expires_in); end
  def enforce_store_method_presence!(method_name); end
  def enforce_store_presence!; end
  def key_and_expiry(unprefixed_key, period); end
end

class Rack::Attack::Check
  # @return [Check] a new instance of Check
  def initialize(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute block.
  def block; end

  # @return [Boolean]
  def matched_by?(request); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute type.
  def type; end
end

class Rack::Attack::Configuration
  # @return [Configuration] a new instance of Configuration
  def initialize; end

  # Returns the value of attribute anonymous_blocklists.
  def anonymous_blocklists; end

  # Returns the value of attribute anonymous_safelists.
  def anonymous_safelists; end

  def blocklist(name = T.unsafe(nil), &block); end
  def blocklist_ip(ip_address); end

  # @return [Boolean]
  def blocklisted?(request); end

  # Returns the value of attribute blocklisted_responder.
  def blocklisted_responder; end

  # Sets the attribute blocklisted_responder
  #
  # @param value the value to set the attribute blocklisted_responder to.
  def blocklisted_responder=(_arg0); end

  # Keeping these for backwards compatibility
  def blocklisted_response; end

  def blocklisted_response=(responder); end

  # Returns the value of attribute blocklists.
  def blocklists; end

  def clear_configuration; end
  def safelist(name = T.unsafe(nil), &block); end
  def safelist_ip(ip_address); end

  # @return [Boolean]
  def safelisted?(request); end

  # Returns the value of attribute safelists.
  def safelists; end

  def throttle(name, options, &block); end

  # @return [Boolean]
  def throttled?(request); end

  # Returns the value of attribute throttled_responder.
  def throttled_responder; end

  # Sets the attribute throttled_responder
  #
  # @param value the value to set the attribute throttled_responder to.
  def throttled_responder=(_arg0); end

  # Keeping these for backwards compatibility
  def throttled_response; end

  def throttled_response=(responder); end

  # Returns the value of attribute throttled_response_retry_after_header.
  def throttled_response_retry_after_header; end

  # Sets the attribute throttled_response_retry_after_header
  #
  # @param value the value to set the attribute throttled_response_retry_after_header to.
  def throttled_response_retry_after_header=(_arg0); end

  # Returns the value of attribute throttles.
  def throttles; end

  def track(name, options = T.unsafe(nil), &block); end

  # @return [Boolean]
  def tracked?(request); end

  private

  def set_defaults; end
end

Rack::Attack::Configuration::DEFAULT_BLOCKLISTED_RESPONDER = T.let(T.unsafe(nil), Proc)
Rack::Attack::Configuration::DEFAULT_THROTTLED_RESPONDER = T.let(T.unsafe(nil), Proc)
class Rack::Attack::Error < ::StandardError; end

class Rack::Attack::Fail2Ban
  class << self
    # @return [Boolean]
    def banned?(discriminator); end

    def filter(discriminator, options); end
    def reset(discriminator, options); end

    protected

    def fail!(discriminator, bantime, findtime, maxretry); end
    def key_prefix; end

    private

    def ban!(discriminator, bantime); end
    def cache; end
  end
end

# When using Rack::Attack with a Rails app, developers expect the request path
# to be normalized. In particular, trailing slashes are stripped.
# (See https://git.io/v0rrR for implementation.)
#
# Look for an ActionDispatch utility class that Rails folks would expect
# to normalize request paths. If unavailable, use a fallback class that
# doesn't normalize the path (as a non-Rails rack app developer expects).
module Rack::Attack::FallbackPathNormalizer
  class << self
    def normalize_path(path); end
  end
end

class Rack::Attack::IncompatibleStoreError < ::Rack::Attack::Error; end
class Rack::Attack::MisconfiguredStoreError < ::Rack::Attack::Error; end
class Rack::Attack::MissingStoreError < ::Rack::Attack::Error; end
Rack::Attack::PathNormalizer = ActionDispatch::Journey::Router::Utils
class Rack::Attack::Railtie < ::Rails::Railtie; end
class Rack::Attack::Request < ::Rack::Request; end

class Rack::Attack::Safelist < ::Rack::Attack::Check
  # @return [Safelist] a new instance of Safelist
  def initialize(name = T.unsafe(nil), &block); end
end

module Rack::Attack::StoreProxy; end

class Rack::Attack::StoreProxy::ActiveSupportRedisStoreProxy < ::Rack::Attack::BaseProxy
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end
  def read(name, options = T.unsafe(nil)); end
  def write(name, value, options = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::DalliProxy < ::Rack::Attack::BaseProxy
  # @return [DalliProxy] a new instance of DalliProxy
  def initialize(client); end

  def delete(key); end
  def increment(key, amount, options = T.unsafe(nil)); end
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  private

  def rescuing; end
  def stub_with_if_missing; end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::MemCacheStoreProxy < ::Rack::Attack::BaseProxy
  def read(name, options = T.unsafe(nil)); end
  def write(name, value, options = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::RedisCacheStoreProxy < ::Rack::Attack::BaseProxy
  def increment(name, amount = T.unsafe(nil), **options); end
  def read(name, options = T.unsafe(nil)); end
  def write(name, value, options = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::RedisProxy < ::Rack::Attack::BaseProxy
  # @return [RedisProxy] a new instance of RedisProxy
  def initialize(*args); end

  def delete(key, _options = T.unsafe(nil)); end
  def delete_matched(matcher, _options = T.unsafe(nil)); end
  def increment(key, amount, options = T.unsafe(nil)); end
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  private

  def rescuing; end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::StoreProxy::RedisStoreProxy < ::Rack::Attack::StoreProxy::RedisProxy
  def read(key); end
  def write(key, value, options = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    def handle?(store); end
  end
end

class Rack::Attack::Throttle
  # @return [Throttle] a new instance of Throttle
  def initialize(name, options, &block); end

  # Returns the value of attribute block.
  def block; end

  def cache; end

  # Returns the value of attribute limit.
  def limit; end

  # @return [Boolean]
  def matched_by?(request); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute period.
  def period; end

  # Returns the value of attribute type.
  def type; end

  private

  def annotate_request_with_matched_data(request, data); end
  def annotate_request_with_throttle_data(request, data); end
  def discriminator_for(request); end
  def limit_for(request); end
  def period_for(request); end
end

Rack::Attack::Throttle::MANDATORY_OPTIONS = T.let(T.unsafe(nil), Array)

class Rack::Attack::Track
  # @return [Track] a new instance of Track
  def initialize(name, options = T.unsafe(nil), &block); end

  # Returns the value of attribute filter.
  def filter; end

  # @return [Boolean]
  def matched_by?(request); end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files

# HTTP method verbs
Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)

# The Rack protocol version number implemented.
Rack::VERSION = T.let(T.unsafe(nil), Array)
