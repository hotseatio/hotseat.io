# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `searchkick` gem.
# Please instead update this file by running `bin/tapioca gem searchkick`.

# based on https://gist.github.com/mnutt/566725
module Searchkick
  class << self
    # Returns the value of attribute aws_credentials.
    def aws_credentials; end

    def aws_credentials=(creds); end

    # message is private
    def callbacks(value = T.unsafe(nil), message: T.unsafe(nil)); end

    # @return [Boolean]
    def callbacks?(default: T.unsafe(nil)); end

    # private
    def callbacks_value; end

    # private
    def callbacks_value=(value); end

    def client; end

    # Sets the attribute client
    #
    # @param value the value to set the attribute client to.
    def client=(_arg0); end

    # Returns the value of attribute client_options.
    def client_options; end

    # Sets the attribute client_options
    #
    # @param value the value to set the attribute client_options to.
    def client_options=(_arg0); end

    # Returns the value of attribute client_type.
    def client_type; end

    # Sets the attribute client_type
    #
    # @param value the value to set the attribute client_type to.
    def client_type=(_arg0); end

    def disable_callbacks; end

    # callbacks
    def enable_callbacks; end

    def env; end

    # Sets the attribute env
    #
    # @param value the value to set the attribute env to.
    def env=(_arg0); end

    # Returns the value of attribute index_prefix.
    def index_prefix; end

    # Sets the attribute index_prefix
    #
    # @param value the value to set the attribute index_prefix to.
    def index_prefix=(_arg0); end

    # Returns the value of attribute index_suffix.
    def index_suffix; end

    # Sets the attribute index_suffix
    #
    # @param value the value to set the attribute index_suffix to.
    def index_suffix=(_arg0); end

    # private
    def indexer; end

    # public (for reindexing conversions)
    #
    # @raise [Error]
    def load_model(class_name, allow_child: T.unsafe(nil)); end

    # private
    #
    # @raise [Error]
    def load_records(relation, ids); end

    # Returns the value of attribute model_options.
    def model_options; end

    # Sets the attribute model_options
    #
    # @param value the value to set the attribute model_options to.
    def model_options=(_arg0); end

    # Returns the value of attribute models.
    def models; end

    # Sets the attribute models
    #
    # @param value the value to set the attribute models to.
    def models=(_arg0); end

    def multi_search(queries); end

    # private
    #
    # @return [Boolean]
    def not_allowed_error?(e); end

    # private
    #
    # @return [Boolean]
    def not_found_error?(e); end

    # @return [Boolean]
    def opensearch?; end

    # Returns the value of attribute queue_name.
    def queue_name; end

    # Sets the attribute queue_name
    #
    # @param value the value to set the attribute queue_name to.
    def queue_name=(_arg0); end

    # Returns the value of attribute redis.
    def redis; end

    # Sets the attribute redis
    #
    # @param value the value to set the attribute redis to.
    def redis=(_arg0); end

    # @raise [Error]
    def reindex_status(index_name); end

    # private
    # methods are forwarded to base class
    # this check to see if scope exists on that class
    # it's a bit tricky, but this seems to work
    #
    # @return [Boolean]
    def relation?(klass); end

    # private
    #
    # @raise [Error]
    def scope(model); end

    def search(term = T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

    # Returns the value of attribute search_method_name.
    def search_method_name; end

    # Sets the attribute search_method_name
    #
    # @param value the value to set the attribute search_method_name to.
    def search_method_name=(_arg0); end

    def search_timeout; end

    # Sets the attribute search_timeout
    #
    # @param value the value to set the attribute search_timeout to.
    def search_timeout=(_arg0); end

    # TODO always check true version in Searchkick 6
    #
    # @return [Boolean]
    def server_below?(version, true_version = T.unsafe(nil)); end

    # private
    def server_info; end

    def server_version; end

    # private
    def signer_middleware_aws_params; end

    # Returns the value of attribute timeout.
    def timeout; end

    # Sets the attribute timeout
    #
    # @param value the value to set the attribute timeout to.
    def timeout=(_arg0); end

    # private
    #
    # @return [Boolean]
    def transport_error?(e); end

    def warn(message); end
    def with_redis; end
  end
end

class Searchkick::BulkReindexJob < ::ActiveJob::Base
  # TODO remove min_id and max_id in Searchkick 6
  def perform(class_name:, record_ids: T.unsafe(nil), index_name: T.unsafe(nil), method_name: T.unsafe(nil), batch_id: T.unsafe(nil), min_id: T.unsafe(nil), max_id: T.unsafe(nil)); end

  class << self
    def queue_name; end
  end
end

module Searchkick::ControllerRuntime
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Searchkick::ControllerRuntime::ClassMethods

  def searchkick_runtime; end
  def searchkick_runtime=(_arg0); end

  protected

  def append_info_to_payload(payload); end
  def cleanup_view_runtime; end
  def process_action(action, *args); end
end

module Searchkick::ControllerRuntime::ClassMethods
  def log_process_action(payload); end
end

class Searchkick::DangerousOperation < ::Searchkick::Error; end

# errors
class Searchkick::Error < ::StandardError; end

# Subclass of `Hashie::Mash` to wrap Hash-like structures
# (responses from Elasticsearch)
#
# The primary goal of the subclass is to disable the
# warning being printed by Hashie for re-defined
# methods, such as `sort`.
class Searchkick::HashWrapper < ::Hashie::Mash; end

class Searchkick::ImportError < ::Searchkick::Error; end

class Searchkick::Index
  # @return [Index] a new instance of Index
  def initialize(name, options = T.unsafe(nil)); end

  # @return [Boolean]
  def alias_exists?; end

  def all_indices(unaliased: T.unsafe(nil)); end
  def batches_left; end
  def bulk_delete(records); end
  def bulk_index(records); end
  def bulk_update(records, method_name); end

  # remove old indices that start w/ index_name
  def clean_indices; end

  # private
  def conversions_fields; end

  def create(body = T.unsafe(nil)); end
  def create_index(index_options: T.unsafe(nil)); end
  def delete; end
  def document_type(record); end

  # @return [Boolean]
  def exists?; end

  def import(records); end
  def import_scope(relation, **options); end
  def index_options; end

  # private
  def klass_document_type(klass, ignore_type = T.unsafe(nil)); end

  # private
  def locations_fields; end

  # call to_h for consistent results between elasticsearch gem 7 and 8
  # could do for all API calls, but just do for ones where return value is focus for now
  def mapping; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end

  def promote(new_name, update_refresh_interval: T.unsafe(nil)); end
  def refresh; end
  def refresh_interval; end

  # note: this is designed to be used internally
  # so it does not check object matches index class
  def reindex(object, method_name: T.unsafe(nil), full: T.unsafe(nil), **options); end

  # queue
  def reindex_queue; end

  def reload_synonyms; end
  def remove(record); end
  def retrieve(record); end
  def search_id(record); end

  # call to_h for consistent results between elasticsearch gem 7 and 8
  def settings; end

  def similar_record(record, **options); end
  def store(record); end

  # private
  def suggest_fields; end

  def swap(new_name, update_refresh_interval: T.unsafe(nil)); end
  def tokens(text, options = T.unsafe(nil)); end
  def total_docs; end
  def update_record(record, method_name); end
  def update_settings(settings); end

  # private
  def uuid; end

  protected

  # safety check
  # still a chance for race condition since its called before promotion
  # ideal is for user to disable automatic index creation
  # https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#index-creation
  def check_uuid(old_uuid, new_uuid); end

  def client; end

  # https://gist.github.com/jarosan/3124884
  # http://www.elasticsearch.org/blog/changing-mapping-with-zero-downtime/
  def full_reindex(relation, import: T.unsafe(nil), resume: T.unsafe(nil), retain: T.unsafe(nil), mode: T.unsafe(nil), refresh_interval: T.unsafe(nil), scope: T.unsafe(nil), wait: T.unsafe(nil)); end

  def import_before_promotion(index, relation, **import_options); end
  def index_settings; end
  def notify(record, name); end
  def notify_bulk(records, name); end
  def queue_delete(records); end
  def queue_index(records); end
  def queue_update(records, method_name); end
  def reindex_records(object, mode: T.unsafe(nil), refresh: T.unsafe(nil), **options); end
  def relation_indexer; end
end

class Searchkick::IndexCache
  # @return [IndexCache] a new instance of IndexCache
  def initialize(max_size: T.unsafe(nil)); end

  def clear; end

  # probably a better pattern for this
  # but keep it simple
  def fetch(name); end
end

class Searchkick::IndexOptions
  # @return [IndexOptions] a new instance of IndexOptions
  def initialize(index); end

  def add_search_synonyms(settings); end
  def add_synonyms(settings); end

  # @return [Boolean]
  def below73?; end

  def default_analyzer; end
  def default_type; end
  def generate_mappings; end

  # @raise [ArgumentError]
  def generate_settings; end

  def index_options; end
  def index_type; end

  # Returns the value of attribute options.
  def options; end

  def set_deep_paging(settings); end
  def update_language(settings, language); end
  def update_stemming(settings); end
end

class Searchkick::Indexer
  # @return [Indexer] a new instance of Indexer
  def initialize; end

  def perform; end
  def queue(items); end

  # Returns the value of attribute queued_items.
  def queued_items; end
end

class Searchkick::InvalidQueryError < ::Searchkick::Error; end

class Searchkick::LogSubscriber < ::ActiveSupport::LogSubscriber
  def multi_search(event); end
  def request(event); end
  def search(event); end

  class << self
    def reset_runtime; end
    def runtime; end
    def runtime=(value); end
  end
end

class Searchkick::Middleware < ::Faraday::Middleware
  def call(env); end
end

class Searchkick::MissingIndexError < ::Searchkick::Error; end

module Searchkick::Model
  # @raise [ArgumentError]
  def searchkick(**options); end
end

class Searchkick::MultiSearch
  # @return [MultiSearch] a new instance of MultiSearch
  def initialize(queries); end

  def perform; end

  # Returns the value of attribute queries.
  def queries; end

  private

  def client; end
  def perform_search(search_queries, perform_retry: T.unsafe(nil)); end
end

class Searchkick::ProcessBatchJob < ::ActiveJob::Base
  def perform(class_name:, record_ids:, index_name: T.unsafe(nil)); end

  class << self
    def queue_name; end
  end
end

class Searchkick::ProcessQueueJob < ::ActiveJob::Base
  def perform(class_name:, index_name: T.unsafe(nil), inline: T.unsafe(nil)); end

  class << self
    def queue_name; end
  end
end

class Searchkick::Query
  include ::Enumerable
  extend ::Forwardable

  # @raise [ArgumentError]
  # @return [Query] a new instance of Query
  def initialize(klass, term = T.unsafe(nil), **options); end

  def [](*args, &block); end
  def aggregations(*args, &block); end
  def aggs(*args, &block); end
  def any?(*args, &block); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  def clear_scroll(*args, &block); end
  def current_page(*args, &block); end
  def each(*args, &block); end
  def each_with_hit(*args, &block); end
  def empty?(*args, &block); end
  def entry_name(*args, &block); end
  def error(*args, &block); end
  def execute; end
  def first(*args, &block); end
  def first_page?(*args, &block); end
  def handle_response(response); end
  def highlights(*args, &block); end
  def hits(*args, &block); end

  # Returns the value of attribute klass.
  def klass; end

  def last_page?(*args, &block); end
  def length(*args, &block); end
  def limit_value(*args, &block); end
  def map(*args, &block); end
  def missing_records(*args, &block); end
  def misspellings?(*args, &block); end
  def model_name(*args, &block); end
  def next_page(*args, &block); end
  def num_pages(*args, &block); end
  def offset(*args, &block); end
  def offset_value(*args, &block); end

  # Returns the value of attribute options.
  def options; end

  def out_of_range?(*args, &block); end
  def padding(*args, &block); end
  def params; end
  def per_page(*args, &block); end
  def prev_page(*args, &block); end
  def previous_page(*args, &block); end
  def records(*args, &block); end
  def response(*args, &block); end
  def results(*args, &block); end

  # @return [Boolean]
  def retry_misspellings?(response); end

  def scroll(*args, &block); end
  def scroll_id(*args, &block); end
  def searchkick_index; end
  def searchkick_klass; end
  def searchkick_options; end
  def size(*args, &block); end
  def slice(*args, &block); end
  def suggestions(*args, &block); end

  # Returns the value of attribute term.
  def term; end

  def to_a(*args, &block); end
  def to_ary(*args, &block); end
  def to_curl; end
  def took(*args, &block); end
  def total_count(*args, &block); end
  def total_entries(*args, &block); end
  def total_pages(*args, &block); end
  def with_details(*args, &block); end
  def with_highlights(*args, &block); end
  def with_hit(*args, &block); end
  def with_score(*args, &block); end

  private

  def base_field(k); end

  # @return [Boolean]
  def below710?; end

  # @return [Boolean]
  def below73?; end

  # @return [Boolean]
  def below75?; end

  def body_options; end
  def boost_filter(field, factor: T.unsafe(nil), modifier: T.unsafe(nil), missing: T.unsafe(nil)); end
  def boost_filters(boost_by, modifier: T.unsafe(nil)); end
  def build_query(query, filters, should, must_not, custom_filters, multiply_filters); end

  # Recursively descend through nesting of arrays until we reach either a lat/lon object or an array of numbers,
  # eventually returning the same structure with all values transformed to [lon, lat].
  def coordinate_array(value); end

  def custom_filter(field, value, factor); end

  # provides *very* basic protection from unfiltered parameters
  # this is not meant to be comprehensive and may be expanded in the future
  def ensure_permitted(obj); end

  def execute_search; end
  def expand_range(range); end
  def handle_error(e); end
  def location_value(value); end
  def prepare; end
  def reindex_command; end
  def set_aggregations(payload, filters, post_filters); end
  def set_boost_by(multiply_filters, custom_filters); end
  def set_boost_by_distance(custom_filters); end
  def set_boost_by_indices(payload); end
  def set_boost_by_recency(custom_filters); end
  def set_boost_where(custom_filters); end
  def set_conversions; end
  def set_exclude(field, analyzer); end
  def set_fields; end
  def set_highlights(payload, fields); end
  def set_order(payload); end
  def set_post_filters(payload, post_filters); end
  def set_suggestions(payload, suggest); end
  def term_filters(field, value); end

  # @return [Boolean]
  def track_total_hits?; end

  def where_filters(where); end
end

class Searchkick::RecordData
  # @return [RecordData] a new instance of RecordData
  def initialize(index, record); end

  def delete_data; end
  def document_type(ignore_type = T.unsafe(nil)); end

  # Returns the value of attribute index.
  def index; end

  def index_data; end

  # Returns the value of attribute record.
  def record; end

  def record_data; end

  # custom id can be useful for load: false
  def search_id; end

  def update_data(method_name); end

  private

  # change all BigDecimal values to floats due to
  # https://github.com/rails/rails/issues/6033
  # possible loss of precision :/
  def cast_big_decimal(obj); end

  def location_value(value); end
  def search_data(method_name = T.unsafe(nil)); end
end

Searchkick::RecordData::TYPE_KEYS = T.let(T.unsafe(nil), Array)

class Searchkick::RecordIndexer
  # @return [RecordIndexer] a new instance of RecordIndexer
  def initialize(index); end

  # Returns the value of attribute index.
  def index; end

  def reindex(records, mode:, method_name:, full: T.unsafe(nil), single: T.unsafe(nil)); end
  def reindex_items(klass, items, method_name:, single: T.unsafe(nil)); end

  private

  def construct_record(klass, id, routing); end

  # import in single request with retries
  def import_inline(index_records, delete_records, method_name:, single:); end

  # @return [Boolean]
  def index_record?(record); end

  def maybe_bulk(index_records, delete_records, method_name, single); end
  def with_retries; end
end

class Searchkick::ReindexQueue
  # @raise [Error]
  # @return [ReindexQueue] a new instance of ReindexQueue
  def initialize(name); end

  def clear; end
  def length; end

  # Returns the value of attribute name.
  def name; end

  # supports single and multiple ids
  def push(record_ids); end

  def push_records(records); end

  # TODO use reliable queuing
  def reserve(limit: T.unsafe(nil)); end

  private

  def escape(value); end
  def redis_key; end
  def redis_version; end

  # @return [Boolean]
  def supports_rpop_with_count?; end
end

class Searchkick::ReindexV2Job < ::ActiveJob::Base
  def perform(class_name, id, method_name = T.unsafe(nil), routing: T.unsafe(nil), index_name: T.unsafe(nil)); end

  class << self
    def queue_name; end
  end
end

class Searchkick::Relation
  # @return [Relation] a new instance of Relation
  def initialize(model, term = T.unsafe(nil), **options); end

  def body(*_arg0, &_arg1); end

  # experimental
  def except(*keys); end

  def execute; end

  # experimental
  def includes(*values); end

  # experimental
  def includes!(*values); end

  # same as Active Record
  def inspect; end

  # experimental
  def limit(value); end

  # experimental
  def limit!(value); end

  # @return [Boolean]
  def loaded?; end

  def method_missing(method, *args, &block); end

  # experimental
  def offset(value = T.unsafe(nil)); end

  # experimental
  def offset!(value); end

  # experimental
  def only(*keys); end

  # experimental
  def order(*values); end

  # experimental
  def order!(*values); end

  # experimental
  def page(value); end

  # experimental
  def page!(value); end

  def params(*_arg0, &_arg1); end

  # experimental
  def per_page(value = T.unsafe(nil)); end

  # experimental
  def per_page!(value); end

  # experimental
  def reorder(*values); end

  # experimental
  def reorder!(*values); end

  # experimental
  def reselect(*values); end

  # experimental
  def reselect!(*values); end

  # experimental
  def rewhere(value); end

  # experimental
  def rewhere!(value); end

  # experimental
  def select(*values, &block); end

  # experimental
  def select!(*values); end

  # experimental
  def where(value = T.unsafe(nil)); end

  # experimental
  def where!(value); end

  private

  # @raise [Error]
  def check_loaded; end

  # provides *very* basic protection from unfiltered parameters
  # this is not meant to be comprehensive and may be expanded in the future
  def ensure_permitted(obj); end

  def private_execute; end
  def query; end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

Searchkick::Relation::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Object)

class Searchkick::RelationIndexer
  # @return [RelationIndexer] a new instance of RelationIndexer
  def initialize(index); end

  def batch_completed(batch_id); end
  def batches_left; end

  # Returns the value of attribute index.
  def index; end

  def reindex(relation, mode:, method_name: T.unsafe(nil), full: T.unsafe(nil), resume: T.unsafe(nil), scope: T.unsafe(nil)); end

  private

  def batch_job(class_name, batch_id, record_ids); end
  def batch_size; end
  def batches_key; end

  # @yield [items]
  def each_batch(relation, batch_size:); end

  def full_reindex_async(relation); end
  def in_batches(relation); end
  def resume_relation(relation); end
end

class Searchkick::Results
  include ::Enumerable
  extend ::Forwardable

  # @return [Results] a new instance of Results
  def initialize(klass, response, options = T.unsafe(nil)); end

  def [](*args, &block); end
  def aggregations; end
  def aggs; end
  def any?(*args, &block); end
  def clear_scroll; end
  def current_page; end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def entry_name(options = T.unsafe(nil)); end
  def error; end

  # @return [Boolean]
  def first_page?; end

  def highlights(multiple: T.unsafe(nil)); end
  def hits; end

  # Returns the value of attribute klass.
  def klass; end

  # @return [Boolean]
  def last_page?; end

  def length(*args, &block); end
  def limit_value; end
  def missing_records; end

  # @return [Boolean]
  def misspellings?; end

  def model_name; end
  def next_page; end
  def num_pages; end
  def offset; end
  def offset_value; end

  # Returns the value of attribute options.
  def options; end

  # @return [Boolean]
  def out_of_range?; end

  def padding; end
  def per_page; end
  def prev_page; end
  def previous_page; end

  # Returns the value of attribute response.
  def response; end

  def results; end

  # @raise [Error]
  def scroll; end

  def scroll_id; end
  def size(*args, &block); end
  def slice(*args, &block); end
  def suggestions; end
  def to_ary(*args, &block); end
  def took; end
  def total_count; end
  def total_entries; end
  def total_pages; end
  def with_highlights(multiple: T.unsafe(nil)); end
  def with_hit; end
  def with_score; end

  private

  def base_field(k); end
  def build_hits; end
  def combine_includes(result, inc); end
  def hit_highlights(hit, multiple: T.unsafe(nil)); end
  def results_query(records, hits); end
  def with_hit_and_missing_records; end
end

class Searchkick::UnsupportedVersionError < ::Searchkick::Error
  def message; end
end

Searchkick::VERSION = T.let(T.unsafe(nil), String)

class Searchkick::Where
  # @return [Where] a new instance of Where
  def initialize(relation); end

  def not(value); end
end

module Searckick; end
class Searckick::Railtie < ::Rails::Railtie; end
